<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Bevy Shader Playground</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Exploring Bevy's Game of Life Example</li><li class="chapter-item expanded "><a href="bevy_gol_example/index.html"><strong aria-hidden="true">1.</strong> Bevy's Game of Life Example</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bevy_gol_example/part_1.html"><strong aria-hidden="true">1.1.</strong> What are shaders?!</a></li><li class="chapter-item expanded "><a href="bevy_gol_example/part_2.html"><strong aria-hidden="true">1.2.</strong> Diving deeper into shaders</a></li><li class="chapter-item expanded "><a href="bevy_gol_example/part_3.html"><strong aria-hidden="true">1.3.</strong> Making cells dance</a></li><li class="chapter-item expanded "><a href="bevy_gol_example/part_4.html"><strong aria-hidden="true">1.4.</strong> Paint like Picaso</a></li><li class="chapter-item expanded "><a href="bevy_gol_example/part_5.html"><strong aria-hidden="true">1.5.</strong> Buffers and UI, Oh My!</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Bevy Shader Playground</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/bayou-brogrammer/bevy_shader_playground/tree/main/docs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Bevy shader playground is a playground to explore and mess with shaders using <a href="https://github.com/bevyengine/bevy">Bevy</a>. I recently found myself fascinated by
shaders and wanted to learn more about them. I started with the great <a href="https://sotrh.github.io/learn-wgpu/">Learn Wgpu</a> tutorial and then found a really neat
tutorial by <a href="https://github.com/hakolao">hakolao</a> which explores compute shaders with <a href="https://github.com/bevyengine/bevy">Bevy</a>
using <a href="https://github.com/vulkano-rs/vulkano">Vulkano</a>. If you are interested, this is the tutorial <a href="https://github.com/hakolao/compute_shader_tutorial">compute_shader_tutorial</a>.</p>
<p>Jump right into the <a href="bevy_gol_example">Bevy Game of Life Shader</a> tutorial.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>Licensed under either of</p>
<ul>
<li>Apache License, Version 2.0 (<a href="LICENSE-APACHE">LICENSE-APACHE</a> or <a href="https://www.apache.org/licenses/LICENSE-2.0">https://www.apache.org/licenses/LICENSE-2.0</a>)</li>
<li>MIT license (<a href="LICENSE-MIT">LICENSE-MIT</a> or <a href="https://opensource.org/licenses/MIT">https://opensource.org/licenses/MIT</a>)
at your option.</li>
</ul>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you,
as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.
You can find the source code on <a href="https://github.com/bayou-brogrammer/bevy_shader_playground">GitHub</a> and issues and feature requests can be posted on
the <a href="https://github.com/bayou-brogrammer/bevy_shader_playground/issues">GitHub issue tracker</a>. Ff you'd like to contribute, please read
the <a href="https://github.com/bayou-brogrammer/bevy_shader_playground/blob/master/CONTRIBUTING.md">CONTRIBUTING</a> guide and consider opening
a <a href="https://github.com/bayou-brogrammer/bevy_shader_playground/pulls">pull request</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bevy-game-of-life-example"><a class="header" href="#bevy-game-of-life-example">Bevy Game of Life Example</a></h1>
<p>This is a mini-tutorial series where I explore how bevy setups up compute shaders using the infamous game of life example. I further
expand on the example by adding some new featues:</p>
<ul>
<li>Camera Controller</li>
<li>Wrapping Simulation</li>
<li>Drawing on the simulation</li>
</ul>
<p>Game of Life simulation:
<img src="bevy_gol_example/images/gol_running.gif" alt="Game of life running" /></p>
<p>Game of Life simulation with drawing:
<img src="bevy_gol_example/images/gol_4_drawing.gif" alt="Game of life drawing" /></p>
<p>Full source code can be found <a href="https://github.com/bayou-brogrammer/bevy_shader_playground/tree/main/sims/game_of_life_sim">here</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bevy-game-of-life-shader-example-part-1"><a class="header" href="#bevy-game-of-life-shader-example-part-1">Bevy Game of Life Shader Example Part 1</a></h1>
<p>As a fun exercise, I decided to explore using compute shaders using wgpu within bevy. This is part 1 of exploring bevy game of life shader example, and
some ways to enhance the experience.</p>
<p>I assume you have general knowledge of rust, bevy, and wgpu, but I will still explain somethings along the way. If you need a refresher on anything, here
are some helpful resources:</p>
<p><a href="https://doc.rust-lang.org/book/">Learn Rust</a></p>
<p><a href="https://bevyengine.org/learn/book/introduction/">Bevy Book</a></p>
<p><a href="https://bevy-cheatbook.github.io/">Bevy Cheatbook</a></p>
<p><a href="https://sotrh.github.io/learn-wgpu/">Learn Wgpu</a></p>
<p>If you are still ready, lets get started!</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>This tutorial currently follows along using <code>Bevy 0.10</code></p>
<p>I am using the <a href="https://github.com/NiklasEi/bevy_game_template">bevy_game_template</a> as my starter, just with all the extra code ripped out,
except for main and lib.</p>
<pre><code class="language-rust">// main.rs

// &lt;imports&gt;
...

fn main() {
    App::new()
        .insert_resource(ClearColor(Color::BLACK))
        .add_plugins(DefaultPlugins.set(WindowPlugin {
            primary_window: Some(Window {
                canvas: Some("#shader_playground".to_owned()),
                title: "Shader Playground".to_string(),
                present_mode: bevy::window::PresentMode::AutoNoVsync, // unthrottled FPS
                ..default()
            }),
            ..default()
        }))
        .add_plugin(ShaderPlaygroundPlugin)
        .add_system(set_window_icon.on_startup())
        .run();
}

// &lt;window_icon sys&gt;
...
</code></pre>
<pre><code class="language-rust">// lib.rs

// &lt;imports&gt;
...

const SIM_SIZE: (u32, u32) = (1280, 720);
const WORKGROUP_SIZE: u32 = 8;

pub struct ShaderPlaygroundPlugin;
impl Plugin for ShaderPlaygroundPlugin {
    fn build(&amp;self, app: &amp;mut App) {
        app.add_plugin(FrameTimeDiagnosticsPlugin::default())
            .add_system(window_fps);
    }
}

fn window_fps(diagnostics: Res&lt;Diagnostics&gt;, mut windows: Query&lt;&amp;mut Window, With&lt;PrimaryWindow&gt;&gt;) {
    if let Ok(mut window) = windows.get_single_mut() {
        if let Some(fps_diagnostic) = diagnostics.get(FrameTimeDiagnosticsPlugin::FPS) {
            if let Some(fps_smoothed) = fps_diagnostic.smoothed() {
                window.title = format!("{fps_smoothed:.2}");
            }
        }
    }
}
</code></pre>
<p>Pretty simple setup. Just added a simple fps system to print the FPS at the top of the window. We need to setup our canvas for our simulation.
We will just use a simple image constrained to our <code>SIM_SIZE</code> variable. You can organize your code how you feel, but I will be breaking out the code
from the original example into separate files for readability.</p>
<pre><code class="language-rust">// image.rs

#[derive(Resource, Clone, Deref, ExtractResource)]
pub struct GameOfLifeImage(pub Handle&lt;Image&gt;);

pub fn create_image(width: u32, height: u32) -&gt; Image {
    let mut image = Image::new_fill(
        Extent3d {
            width,
            height,
            depth_or_array_layers: 1,
        },
        TextureDimension::D2,
        &amp;[0, 0, 0, 255],
        TextureFormat::Rgba8Unorm,
    );

    image.texture_descriptor.usage =
        TextureUsages::COPY_DST | TextureUsages::STORAGE_BINDING | TextureUsages::TEXTURE_BINDING;

    image
}
</code></pre>
<p>This is just a simple helper function to create an image. We will be using this to create our simulation image. <code>GameOfLifeImage</code> will hold a reference to our
handle image so that it doesn't get unloaded. You will see it is annotated with <code>ExtractResource</code> derive. This is required to extract the image from the main bevy
world into the render world. You can also manually derive this, if needed. Lets use it within our setup function. Back in
<code>lib.rs</code>:</p>
<pre><code class="language-rust">...
fn setup(mut commands: Commands, mut images: ResMut&lt;Assets&lt;Image&gt;&gt;) {
    let image = image::create_image(SIM_SIZE.0, SIM_SIZE.1);
    let image = images.add(image);

    commands.spawn(SpriteBundle {
        sprite: Sprite {
            custom_size: Some(Vec2::new(SIM_SIZE.0 as f32, SIM_SIZE.1 as f32)),
            ..default()
        },
        texture: image.clone(),
        ..default()
    });

    commands.spawn(Camera2dBundle::default());
    commands.insert_resource(image::GameOfLifeImage(image));
}</code></pre>
<p>Quick and easy. Just create our image, create a sprite based off the image, spawn a 2D camera, and then inject our resource into bevy world.
Now we just need to hookup our system back in the plugin.</p>
<pre><code class="language-rust">fn build(&amp;self, app: &amp;mut App) {
    app.add_plugin(FrameTimeDiagnosticsPlugin::default())
        .add_startup_system(setup)
        .add_system(window_fps);
}</code></pre>
<p>Running the simulation should produce a black screen and nothing more. But hey! No errors! Lets move on.</p>
<p>As mentioned earlier, bevy has a render world which is extracted each render instance. We need to tell our render setup how to access members from the main world.
In our plugin, add the <code>ExtractResourcePlugin</code> for our <code>GameOfLifeImage</code> resource.</p>
<pre><code class="language-rust">...
// Extract the game of life image resource from the main world into the render world
// for operation on by the compute shader and display on the sprite.
app.add_plugin(ExtractResourcePlugin::&lt;GameOfLifeImage&gt;::default());
...</code></pre>
<p>Now onto the actual meat of why I am writing this. Lets get into wgpu. We will be using a compute shader, so our pipeline will need to be a <code>ComputePipeline</code>.</p>
<blockquote>
<p>A pipeline describes all the actions the gpu will perform when acting on a set of data</p>
</blockquote>
<p>Lets create a new file, <code>pipeline.rs</code> and add the following:</p>
<pre><code class="language-rust">use bevy::{prelude::*, render::render_resource::*};

#[derive(Resource)]
pub struct GameOfLifePipeline {
    init_pipeline: CachedComputePipelineId,
    update_pipeline: CachedComputePipelineId,
    texture_bind_group_layout: BindGroupLayout,
}

impl FromWorld for GameOfLifePipeline {
    fn from_world(world: &amp;mut World) -&gt; Self {}
}
</code></pre>
<p>Our pipeline resource holds the two compute pipeline id's we will be using init (for setup) and update (for each frame). We also need to hold onto
the bind group layout.</p>
<blockquote>
<p>a bind group layout is a way to describe the structure of resources that a shader will access during execution. The resources include buffers, textures, and samplers</p>
</blockquote>
<p>Lets expand upon our <code>FromWorld</code> implementation.</p>
<pre><code class="language-rust">impl FromWorld for GameOfLifePipeline {
    fn from_world(world: &amp;mut World) -&gt; Self {
        let texture_bind_group_layout =
            world
                .resource::&lt;RenderDevice&gt;()
                .create_bind_group_layout(&amp;BindGroupLayoutDescriptor {
                    label: Some("Game of Life Bind Group Layout"),
                    entries: &amp;[BindGroupLayoutEntry {
                        binding: 0,
                        visibility: ShaderStages::COMPUTE,
                        ty: BindingType::StorageTexture {
                            access: StorageTextureAccess::ReadWrite,
                            format: TextureFormat::Rgba8Unorm,
                            view_dimension: TextureViewDimension::D2,
                        },
                        count: None,
                    }],
                });

        let pipeline_cache = world.resource::&lt;PipelineCache&gt;();
        let shader = world
            .resource::&lt;AssetServer&gt;()
            .load("shaders/game_of_life.wgsl");

        ...</code></pre>
<p>WHOA! What is this weird layout stuff? First thing first, the <code>RenderDevice</code> is equivalent to <code>wgpu::Device</code>. We are just using the bevy wrapper.
I like to add labels to all my shader creations, just to make it easier to track bugs when they do arise. This layout is telling the pipeline that at
binding(0) we expect there to be a binding of type <code>StorageTexture</code>, that is read_write, and has the format of <code>Rgba8Unorm</code>.</p>
<p>We then pull the pipeline cache to create our pipelines and pull our shader from the asset's folder.</p>
<h2 id="compute-shaders"><a class="header" href="#compute-shaders">Compute Shaders</a></h2>
<blockquote>
<p>A compute shader is simply a shader that allows you to leverage the GPU's parallel computing power for arbitrary tasks. You can use them for anything from creating a texture to running a neural network. I'll get more into how they work in a bit, but for now suffice to say that we're going to use them to create the vertex and index buffers for our terrain.
As of writing, compute shaders are still experimental on the web. You can enable them on beta versions of browsers such as Chrome Canary and Firefox Nightly. Because of this I'll cover a method to use a fragment shader to compute the vertex and index buffers after we cover the compute shader method.</p>
</blockquote>
<pre><code class="language-rust">    let init_pipeline = pipeline_cache.queue_compute_pipeline(ComputePipelineDescriptor {
        shader: shader.clone(),
        shader_defs: vec![],
        layout: vec![texture_bind_group_layout.clone()],
        entry_point: Cow::from("init"),
        push_constant_ranges: Vec::new(),
        label: Some(std::borrow::Cow::Borrowed("Game of Life Init Pipeline")),
    });
    let update_pipeline = pipeline_cache.queue_compute_pipeline(ComputePipelineDescriptor {
        shader,
        shader_defs: vec![],
        layout: vec![texture_bind_group_layout.clone()],
        entry_point: Cow::from("update"),
        push_constant_ranges: Vec::new(),
        label: Some(std::borrow::Cow::Borrowed("Game of Life Update Pipeline")),
    });

    GameOfLifePipeline {
        texture_bind_group_layout,
        init_pipeline,
        update_pipeline,
    }</code></pre>
<p>The init and update pipeline use the same layout and shader. We are not using push constants yet, so we can leave that as an empty vector, same with shader_defs.
The important part is the entry_point. This is the name of the function in the shader that will be executed.</p>
<p>Lets quickly setup our shader and then we can move onto the actual compute shader.</p>
<pre><code class="language-glsl">// assets/game_of_life.wgsl

@group(0) @binding(0)
var texture: texture_storage_2d&lt;rgba8unorm, read_write&gt;;

@compute @workgroup_size(8, 8, 1)
fn init(@builtin(global_invocation_id) invocation_id: vec3&lt;u32&gt;, @builtin(num_workgroups) num_workgroups: vec3&lt;u32&gt;) {}

@compute @workgroup_size(8, 8, 1)
fn update(@builtin(global_invocation_id) invocation_id: vec3&lt;u32&gt;) {}
</code></pre>
<p>We can see that from what we defined in our <code>BindGroupLayoutDescriptor</code> that we define a <code>texture_storage_2d&lt;rgba8unorm, read_write&gt;</code> at <code>binding(0)</code>. Looking
back at our descriptor:</p>
<pre><code class="language-rust">BindGroupLayoutDescriptor {
    label: Some("Game of Life Bind Group Layout"),
    entries: &amp;[BindGroupLayoutEntry {
        binding: 0,
        visibility: ShaderStages::COMPUTE,
        ty: BindingType::StorageTexture {
            access: StorageTextureAccess::ReadWrite,
            format: TextureFormat::Rgba8Unorm,
            view_dimension: TextureViewDimension::D2,
        },
        count: None,
    }],
}</code></pre>
<p>We see that our <code>BindGroupLayoutEntry</code> matches what we expect at <code>group(0) binding(0)</code>. This has to match 1:1, otherwise wgpu will panic on run.</p>
<p>Afterwards, we simply just adds our entry points that we defined in the pipeline's. The <code>@workgroup_size</code> is the size of the workgroup that will be
executed on the gpu. Bevy example uses 8.
Let's add our newly created pipeline resource to the render world. Back in the plugin:</p>
<pre><code class="language-rust">...
let render_app = app.sub_app_mut(RenderApp);
render_app.init_resource::&lt;GameOfLifePipeline&gt;();</code></pre>
<p>Running the example now should produce the same screen, but still no errors. We are getting closer to actually doing something. More in part 2.</p>
<p>Code can be found on github: <a href="https://github.com/bayou-brogrammer/bevy_shader_playground/tree/explore_part1/sims/game_of_life_sim/src">Part 1</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bevy-game-of-life-shader-example-part-2"><a class="header" href="#bevy-game-of-life-shader-example-part-2">Bevy Game of Life Shader Example Part 2</a></h1>
<p>Now that we have our pipeline descriptors setup, its time to build the bind group.</p>
<blockquote>
<p>A <code>BindGroup</code> is a collection of resources such as buffers, textures, and samplers that are bound together and made available
to shaders during rendering. Bind groups are created by the application and then bound to a specific pipeline layout,
which defines the expected bindings for the resources in the group.</p>
</blockquote>
<p>At the bottom of our <code>pipeline.rs</code> file, lets add the system which will create our bindgroup each render instance.</p>
<pre><code class="language-rust">...

#[derive(Resource)]
struct GameOfLifeImageBindGroup(pub BindGroup);

pub fn queue_bind_group(
    mut commands: Commands,
    render_device: Res&lt;RenderDevice&gt;,
    pipeline: Res&lt;GameOfLifePipeline&gt;,
    gpu_images: Res&lt;RenderAssets&lt;Image&gt;&gt;,
    game_of_life_image: Res&lt;GameOfLifeImage&gt;,
) {
    let view = &amp;gpu_images[&amp;game_of_life_image.0];
}</code></pre>
<!-- more -->
<p>Starting off we pull in <code>RenderDevice</code> which is used to create all wgpu resources. <code>RenderAssets&lt;Image&gt;</code> is a resource holding all the GPU representations
of <code>RenderAssets</code> as long as they exist. We use the handle from the image we created as our canvas, to get the <code>GpuImage</code>. Now the bind group:</p>
<pre><code class="language-rust">...
let bind_group = render_device.create_bind_group(&amp;BindGroupDescriptor {
    label: Some("Game of Life Bind Group"),
    layout: &amp;pipeline.texture_bind_group_layout,
    entries: &amp;[BindGroupEntry {
        binding: 0,
        resource: BindingResource::TextureView(&amp;view.texture_view),
    }],
});
commands.insert_resource(GameOfLifeImageBindGroup(bind_group));</code></pre>
<p>Well this looks really familiar! It is an exact replica of the bind_group_layout we created earlier. The only difference is that we are now adding
the actual resources that the layout expects. In this case we are adding the texture view of our canvas image. Lets add the system to our render app.</p>
<pre><code class="language-rust">...
let render_app = app.sub_app_mut(RenderApp);
        render_app
            .init_resource::&lt;GameOfLifePipeline&gt;()
            .add_system(pipeline::queue_bind_group.in_set(RenderSet::Queue));</code></pre>
<p>We add our system to the set <code>RenderSet::Queue</code> which create <code>BindGroups</code> that depend on <code>Prepare</code> data and queue up draw calls to run during the <code>Render</code> step.
If you try running the app, it will currently crash with the following error:</p>
<p><code>Resource requested by game_of_life_sim::pipeline::queue_bind_group does not exist: game_of_life_sim::image::GameOfLifeImage</code></p>
<p>Oops! We forgot to tell bevy render world how to access our Image which exist on the main world. Let's add the <code>ExtractResourcePlugin</code> which just
extracts the resources into the "render world".</p>
<pre><code class="language-rust">app.add_plugin(FrameTimeDiagnosticsPlugin::default())
    // Extract the game of life image resource from the main world into the render world
    // for operation on by the compute shader and display on the sprite.
    .add_plugin(ExtractResourcePlugin::&lt;GameOfLifeImage&gt;::default())
    ...</code></pre>
<p>If you run again, no errors! Awesome :D. Now onto nodes and the render graph. This was new to me after I setup wgpu manually in my other projects. If you are curious,
this is the docstring attached to the <code>RenderGraph</code> resource:</p>
<blockquote>
<p>The <code>RenderGraph</code> configures the modular, parallel and re-usable render logic. It is a retained and stateless (nodes themselves may have their own
internal state) structure, which can not be modified while it is executed by the graph runner.
The <code>RenderGraphRunner</code> is responsible for executing the entire graph each frame. It consists of three main components: Nodes, Edges and Slots.
<code>Nodes</code> are responsible for generating draw calls and operating on input and output slots. <code>Edges</code> specify the order of execution for nodes and connect input and output slots together.
<code>Slots</code> describe the render resources created or used by the nodes.
Additionally a render graph can contain multiple sub graphs, which are run by the corresponding nodes. Every render graph can have its own optional input node.</p>
</blockquote>
<p>Essentially we setup a graph to tell the render world how to run our pipelines. We only have a single pipeline currently, so we will only need a single node.</p>
<p>Our node will have a state for processing which stage the shader is currently in: <code>Loading</code>, <code>Init</code>, <code>Update</code>. Back in <code>pipeline.rs</code> lets add our node:</p>
<pre><code class="language-rust">...
pub enum GameOfLifeState {
    Loading,
    Init,
    Update,
}

pub struct GameOfLifeNode {
    state: GameOfLifeState,
}

impl Default for GameOfLifeNode {
    fn default() -&gt; Self {
        Self {
            state: GameOfLifeState::Loading,
        }
    }
}</code></pre>
<p>Lets add the node to our render app:</p>
<pre><code class="language-rust">let render_app = app.sub_app_mut(RenderApp);
render_app
    .init_resource::&lt;GameOfLifePipeline&gt;()
    .add_system(pipeline::queue_bind_group.in_set(RenderSet::Queue));

let mut render_graph = render_app.world.resource_mut::&lt;RenderGraph&gt;();
render_graph.add_node("game_of_life", GameOfLifeNode::default());
render_graph.add_node_edge(
    "game_of_life",
    bevy::render::main_graph::node::CAMERA_DRIVER,
);</code></pre>
<p>We add the node to the render graph and then add an edge to the camera driver. This will tell the render graph to run our node before the camera driver.</p>
<p>Our node starts in the Loading state. We now have to impl bevy's <code>render_graph::Node</code>: The trait is defined as follow:</p>
<pre><code class="language-rust">pub trait Node: Downcast + Send + Sync + 'static {
    /// Specifies the required input slots for this node.
    /// They will then be available during the run method inside the [`RenderGraphContext`].
    fn input(&amp;self) -&gt; Vec&lt;SlotInfo&gt; {
        Vec::new()
    }

    /// Specifies the produced output slots for this node.
    /// They can then be passed one inside [`RenderGraphContext`] during the run method.
    fn output(&amp;self) -&gt; Vec&lt;SlotInfo&gt; {
        Vec::new()
    }

    /// Updates internal node state using the current render [`World`] prior to the run method.
    fn update(&amp;mut self, _world: &amp;mut World) {}

    /// Runs the graph node logic, issues draw calls, updates the output slots and
    /// optionally queues up subgraphs for execution. The graph data, input and output values are
    /// passed via the [`RenderGraphContext`].
    fn run(
        &amp;self,
        graph: &amp;mut RenderGraphContext,
        render_context: &amp;mut RenderContext,
        world: &amp;World,
    ) -&gt; Result&lt;(), NodeRunError&gt;;
}</code></pre>
<p>The <code>input</code> defines required input slots and <code>output</code> defines produced output slots. This will exist on the <code>RenderGraphContext</code>. Our example doesn't
use either, so we don't care for the graph context.</p>
<pre><code class="language-rust">impl render_graph::Node for GameOfLifeNode {
    fn update(&amp;mut self, world: &amp;mut World) {
        let pipeline = world.resource::&lt;GameOfLifePipeline&gt;();
        let pipeline_cache = world.resource::&lt;PipelineCache&gt;();

        // if the corresponding pipeline has loaded, transition to the next stage
        match self.state {
            GameOfLifeState::Loading =&gt; {
                if let CachedPipelineState::Ok(_) =
                    pipeline_cache.get_compute_pipeline_state(pipeline.init_pipeline)
                {
                    self.state = GameOfLifeState::Init;
                }
            }
            GameOfLifeState::Init =&gt; {
                if let CachedPipelineState::Ok(_) =
                    pipeline_cache.get_compute_pipeline_state(pipeline.update_pipeline)
                {
                    self.state = GameOfLifeState::Update;
                }
            }
            GameOfLifeState::Update =&gt; {}
        }
    }

    fn run(
        &amp;self,
        _graph: &amp;mut render_graph::RenderGraphContext,
        render_context: &amp;mut RenderContext,
        world: &amp;World,
    ) -&gt; Result&lt;(), render_graph::NodeRunError&gt; {
        Ok(())
    }
}</code></pre>
<p>Lets focus on the <code>update</code> method. We are checking if the pipeline has loaded. If it has, we transition to the next stage. For update,
we have no other state to transition to, but if you needed to recreate your pipeline or rerun your init pipeline, you would do change the state here.</p>
<p>The fun stuff: <code>run</code>. This is where we will be running our compute shaders. Let's setup the init pipeline first:</p>
<pre><code class="language-rust">fn run(
        &amp;self,
        _graph: &amp;mut render_graph::RenderGraphContext,
        render_context: &amp;mut RenderContext,
        world: &amp;World,
    ) -&gt; Result&lt;(), render_graph::NodeRunError&gt; {
        let texture_bind_group = &amp;world.resource::&lt;GameOfLifeImageBindGroup&gt;().0;
        let pipeline_cache = world.resource::&lt;PipelineCache&gt;();
        let pipeline = world.resource::&lt;GameOfLifePipeline&gt;();
        ...</code></pre>
<p>We have to pull 3 resources from the world: <code>GameOfLifeImageBindGroup</code>, <code>PipelineCache</code>, and <code>GameOfLifePipeline</code>. We are already familiar
with the pipeline and pipeline cache, but the new resource <code>GameOfLifeImageBindGroup</code> is a <code>BindGroup</code> that we queue each frame to be used by the shader.
Now we begin the <code>ComputePass</code>.</p>
<pre><code class="language-rust">...
let mut pass = render_context
    .command_encoder()
    .begin_compute_pass(&amp;ComputePassDescriptor::default());
...</code></pre>
<p>Since we are only using compute shaders, we need to begin a compute pass, the other side of the coin is a render pass for vertex and fragment shaders.</p>
<pre><code class="language-rust">...
pass.set_bind_group(0, texture_bind_group, &amp;[]);
...</code></pre>
<p>Assign our bindgroup the the compute pass. Then we pull the state defined from our node to see which piplline to execute.</p>
<pre><code class="language-rust">// select the pipeline based on the current state
match self.state {
    GameOfLifeState::Update | GameOfLifeState::Loading =&gt; {}
    GameOfLifeState::Init =&gt; {
        let init_pipeline = pipeline_cache
            .get_compute_pipeline(pipeline.init_pipeline)
            .unwrap();
        pass.set_pipeline(init_pipeline);
        pass.dispatch_workgroups(
            SIM_SIZE.0 / WORKGROUP_SIZE,
            SIM_SIZE.1 / WORKGROUP_SIZE,
            1,
        );
    }
}</code></pre>
<p>We are skipping the update pipeline currently, but we will come back to it. For the init state, we want to run the init pipeline. We set the pipeline using our
<code>CachedComputePipelineId</code> defined in our <code>GameOfLifePipeline</code>. Then we dispatch the workgroups. The function takes 3 arguments: <code>x</code>, <code>y</code>, <code>z</code>. In our shader,
we defined our workgroup size as 8x8x1. <code>@compute @workgroup_size(8, 8, 1)</code></p>
<p>A visual representation of work groups: <a href="https://github.com/sotrh/learn-wgpu/raw/master/docs/intermediate/tutorial13-terrain/figure_work-groups.jpg">Work Groups</a>.</p>
<p>It may be helpful to think of a compute shader as a function that is run in a bunch of nested for loops, but each loop is executed in parallel. It would look something like this:</p>
<pre><code class="language-rust">for wgx in num_workgroups.x:
    for wgy in num_workgroups.y:
        for wgz in num_workgroups.z:
            var local_invocation_id = (wgx, wgy, wgz)
            for x in workgroup_size.x:
                for y in workgroup_size.x:
                    for z in workgroup_size.x:</code></pre>
<p>Running still produces the same black screen, but I promise the init pipeline triggered once, we just need to add code to our shader now! Bevy uses wgpu internally,
which uses wgsl as their default shader language. They also support GLSL, but a word of warning, there can be some weird quirks when using GLSL with wgpu.</p>
<p>To start with our <code>init</code> function in our shader, we see some function inputs:</p>
<pre><code class="language-glsl">fn init(@builtin(global_invocation_id) invocation_id: vec3&lt;u32&gt;, @builtin(num_workgroups) num_workgroups: vec3&lt;u32&gt;) 
</code></pre>
<p>This is a builtin value for the current invocation’s global invocation ID, i.e. its position in the compute shader grid. WGSL has many builtin values
and functions. Please refer to the spec for more info <a href="https://www.w3.org/TR/WGSL/">WebGPU Shading Language</a>.</p>
<p>And the <code>num_workgroups</code> is the number of workgroups in each dimension.</p>
<pre><code class="language-glsl">fn init(@builtin(global_invocation_id) invocation_id: vec3&lt;u32&gt;, @builtin(num_workgroups) num_workgroups: vec3&lt;u32&gt;) {
    let location = vec2&lt;i32&gt;(invocation_id.xy);
}
</code></pre>
<p>We can get the current location within the shader by casting the invocation.xy to an i32.</p>
<blockquote>
<p>invocation.xy is short hand for invocation.x and invocation.y</p>
</blockquote>
<p>We want to randomize our initial state, so lets define a random function.</p>
<pre><code class="language-glsl">fn hash(value: u32) -&gt; u32 {
    var state = value;
    state = state ^ 2747636419u;
    state = state * 2654435769u;
    state = state ^ state &gt;&gt; 16u;
    state = state * 2654435769u;
    state = state ^ state &gt;&gt; 16u;
    state = state * 2654435769u;
    return state;
}

fn randomFloat(value: u32) -&gt; f32 {
    return f32(hash(value)) / 4294967295.0;
}
</code></pre>
<p>There are many hash / random functions you can find online. Each with their own pros and cons. I am just using the bevy default.</p>
<blockquote>
<p>2654435769u is a inline cast like in rust with 2654435769_u32. The u is for u32.</p>
</blockquote>
<pre><code class="language-glsl">let randomNumber = randomFloat(invocation_id.y * num_workgroups.x + invocation_id.x);
let alive = randomNumber &gt; 0.9;
</code></pre>
<p>We generate a random number, and if it is greater than 0.9, we set the cell to alive. We can now set the cell in our texture. Play around with what denotes
and alive cell. Lowering <code>0.9</code> will generate more alive cells and vice versa. Lets finish off the init.</p>
<pre><code class="language-glsl">fn init(@builtin(global_invocation_id) invocation_id: vec3&lt;u32&gt;, @builtin(num_workgroups) num_workgroups: vec3&lt;u32&gt;) {
    let location = vec2&lt;i32&gt;(invocation_id.xy);

    let randomNumber = randomFloat(invocation_id.y * num_workgroups.x + invocation_id.x);
    let alive = randomNumber &gt; 0.9;
    let color = vec4&lt;f32&gt;(f32(alive));

    textureStore(texture, location, color);
}
</code></pre>
<p>You might be curious what <code>vec4&lt;f32&gt;(f32(alive))</code> is doing here. <code>vec4&lt;f32&gt;()</code> is casting the value to a <code>vec4&lt;f32&gt;</code>. We are using the <code>f32()</code> function to cast
the alive value from a <code>bool</code> to a <code>f32</code>. So if alive the color will be <code>vec4&lt;f32&gt;(1.0)</code> or <code>(1.0,1.0,1.0,1.0)</code> and if dead <code>vec4&lt;f32&gt;(0.0)</code> or <code>(0.0,0.0,0.0,0.0)</code>.</p>
<p>And now the moment of truth, we can run our code and see the results! Running should produce something like this:</p>
<p><img src="bevy_gol_example/images/gol_part2.png" alt="Game of life" /></p>
<p>Code can be found on github: <a href="https://github.com/bayou-brogrammer/bevy_shader_playground/tree/explore_part2/sims/game_of_life_sim/src">Part 2</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bevy-game-of-life-shader-example-part-3"><a class="header" href="#bevy-game-of-life-shader-example-part-3">Bevy Game of Life Shader Example Part 3</a></h1>
<p>It is exciting to finally see some progress after so much boilerplate! Let's change up the color scheme a bit! I like the color red, so let's make the
alive cells red. In our shader, switch the init_pipeline color to the following:</p>
<pre><code class="language-glsl">@compute @workgroup_size(8, 8, 1)
fn init(@builtin(global_invocation_id) invocation_id: vec3&lt;u32&gt;, @builtin(num_workgroups) num_workgroups: vec3&lt;u32&gt;) {
    let location = vec2&lt;i32&gt;(invocation_id.xy);

    let randomNumber = randomFloat(invocation_id.y * num_workgroups.x + invocation_id.x);
    let alive = randomNumber &gt; 0.9;
    let color = vec4&lt;f32&gt;(f32(alive), 0.0, 0.0, 1.0); // NEW

    textureStore(texture, location, color);
}
</code></pre>
<p>And you should see something like this:</p>
<p><img src="bevy_gol_example/images/gol_part3_red.png" alt="Game of life red" /></p>
<p>Very red! Now onto our update pipeline, which makes all this worth it to see the cells move.</p>
<h2 id="update-pipeline"><a class="header" href="#update-pipeline">Update Pipeline</a></h2>
<p>Back in <code>pipeline.rs</code> lets update our match statement within the run function of our node.</p>
<pre><code class="language-rust">// select the pipeline based on the current state
match self.state {
    GameOfLifeState::Loading =&gt; {}
    GameOfLifeState::Init =&gt; {
        let init_pipeline = pipeline_cache
            .get_compute_pipeline(pipeline.init_pipeline)
            .unwrap();
        pass.set_pipeline(init_pipeline);
        pass.dispatch_workgroups(
            SIM_SIZE.0 / WORKGROUP_SIZE,
            SIM_SIZE.1 / WORKGROUP_SIZE,
            1,
        );
    }
    GameOfLifeState::Update =&gt; {
        let update_pipeline = pipeline_cache
            .get_compute_pipeline(pipeline.update_pipeline)
            .unwrap();
        pass.set_pipeline(update_pipeline);
        pass.dispatch_workgroups(
            SIM_SIZE.0 / WORKGROUP_SIZE,
            SIM_SIZE.1 / WORKGROUP_SIZE,
            1,
        );
    }
}</code></pre>
<p>It is exactly the same as the init pipeline, we just use the update pipeline instead. That takes care of the rust side of things, now onto the shader.</p>
<h2 id="conways-game-of-life"><a class="header" href="#conways-game-of-life">Conway's Game of Life</a></h2>
<p>The particular bit of cellular automata we are implementing is <code>Conway's Game of Life</code>. The rules are as follows:</p>
<ol>
<li>Any live cell with fewer than two live neighbours dies, as if by underpopulation.</li>
<li>Any live cell with two or three live neighbours lives on to the next generation.</li>
<li>Any live cell with more than three live neighbours dies, as if by overpopulation.</li>
<li>Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.</li>
</ol>
<p>These rules, which compare the behaviour of the automaton to real life, can be condensed into the following:</p>
<ol>
<li>Any live cell with two or three live neighbours survives.</li>
<li>Any dead cell with three live neighbours becomes a live cell.</li>
<li>All other live cells die in the next generation. Similarly, all other dead cells stay dead.</li>
</ol>
<p>Back in our update fn, lets start by pulling the current location</p>
<pre><code class="language-glsl">@compute @workgroup_size(8, 8, 1)
fn update(@builtin(global_invocation_id) invocation_id: vec3&lt;u32&gt;) {
    let location = vec2&lt;i32&gt;(invocation_id.xy);
}
</code></pre>
<p>Now we need to count the number of alive neighbors, but to do that, we need a way to tell if a cell is alive or dead.
Add the following utility function</p>
<pre><code class="language-glsl">...
fn is_alive(location: vec2&lt;i32&gt;, offset_x: i32, offset_y: i32) -&gt; u32 {
    let value: vec4&lt;f32&gt; = textureLoad(texture, location + vec2&lt;i32&gt;(offset_x, offset_y));
    return u32(value.x);
}
...
</code></pre>
<p>This function takes in a location, and an offset. We store all our data within the texture itself as colors. (in our instance its red colors for alive <br />
and black for dead). <code>textureLoad</code> loads the color at the given location. We know a cell is alive if the color returned is red, which is a value of 1.0 a <code>x</code></p>
<p>Now that we have a way to tell if a cell is alive, we can move onto counting the neighbors. We need to check the 8 cells surrounding the current cell.
We can achieve this using a simple nested for loop. Here is what I came up with:</p>
<pre><code class="language-glsl">fn count_neighbors_simple(location: vec2&lt;i32&gt;) -&gt; u32 {
    var result: u32 = 0u;
    for (var x: i32 = -1; x &lt; 2; x++) {
        for (var y: i32 = -1; y &lt; 2; y++) {
            if x == 0 &amp;&amp; y == 0 {
                continue;
            }

            result += is_alive(location, x, y); 
        }
    }
    return result;
}
</code></pre>
<p>We take in a location to count the neighbors of, and return the number of alive neighbors by looping through the 8 surrounding cells
and calling our <code>is_alive</code> function. Lets add this to our update function:</p>
<pre><code class="language-glsl">@compute @workgroup_size(8, 8, 1)
fn update(@builtin(global_invocation_id) invocation_id: vec3&lt;u32&gt;) {
    let location = vec2&lt;i32&gt;(invocation_id.xy);
    let is_alive = bool(is_alive(location, 0, 0));
    let num_neighbors = count_neighbors_simple(location);
}
</code></pre>
<p>It is pretty staight forward from here, we just need to implement the rules from above.</p>
<pre><code class="language-glsl">...

var result: u32 = 0u;

if (is_alive) { 
    result = ((u32((num_neighbors) == (2u))) | (u32((num_neighbors) == (3u)))); 
} else { 
    result = u32((num_neighbors) == (3u)); 
}

let color = vec4&lt;f32&gt;(f32(result), 0.0, 0.0, 1.0);
textureStore(texture, location, color);
</code></pre>
<p>If the current cell is alive, we check if it has 2 or 3 neighbors, if it does, it lives on, otherwise it dies. If the current cell is dead,
we check if it has 3 neighbors, if it does, it becomes alive, otherwise it stays dead. Then we store our result as a color in the texture (red in this case).</p>
<blockquote>
<p>Note: I removed the window_fps plugin and <code>FrameTimeDiagnosticsPlugin</code> plugin. It was slowing down my app when running.
I also disabled <code>bevy::window::PresentMode::AutoNoVsync</code> otherwise, the app runs at like 3k fps XD</p>
</blockquote>
<p>Running the app should now show the cells moving around!!! How cool!</p>
<p><img src="bevy_gol_example/images/gol_running.gif" alt="gol_running" /></p>
<p>Code can be found on github: <a href="https://github.com/bayou-brogrammer/bevy_shader_playground/tree/explore_part3/sims/game_of_life_sim/src">Part 3</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bevy-game-of-life-shader-example-part-4"><a class="header" href="#bevy-game-of-life-shader-example-part-4">Bevy Game of Life Shader Example Part 4</a></h1>
<p>I promised some additions to the original example provided so lets start with the easiest one, a simple camera controller.
I just want to be able to pan around the simulation and zoom in a bit. I am going to run a cleanup and refactor for readability and
cleanliness.</p>
<ul>
<li>Create three new files, <code>camera.rs</code>, <code>input.rs</code>, and <code>utils.rs</code>, along with the a folder <code>pipeline</code>. It is important the pipeline folder is named exactly
as the <code>pipeline.rs</code> file as I am not using <code>mod.rs</code> files.</li>
<li>Move the function <code>create_image</code> into our utils folder and delete the image file.</li>
<li>Inside <code>pipeline</code> folder create a <code>automata.rs</code> file and move all the pipeline code from our past
three posts into it. This includes the <code>Pipeline</code>, <code>TextureBindGroup</code>, <code>State</code>, and <code>Node</code>.</li>
</ul>
<!-- more -->
<p>I also renamed some things. Here is a mapping:</p>
<ul>
<li><code>Pipeline</code> -&gt; <code>AutomataPipeline</code></li>
<li><code>GameOfLifeImageBindGroup</code> -&gt; <code>AutomataTextureBindGroup</code></li>
<li><code>GameOfLifeState</code> -&gt; <code>AutomataState</code></li>
<li><code>GameOfLifeNode</code> -&gt; <code>AutomataNode</code></li>
</ul>
<p>Lets add a simple plugin to host from this file at the top:</p>
<pre><code class="language-rust">
#[derive(Resource, Clone, Deref, ExtractResource)]
pub struct GameOfLifeImage(pub Handle&lt;Image&gt;);

pub struct AutomataPipelinePlugin;
impl Plugin for AutomataPipelinePlugin {
    fn build(&amp;self, render_app: &amp;mut App) {
        render_app
            .init_resource::&lt;GameOfLifeAutomataPipeline&gt;()
            .add_system(queue_automata_bind_group.in_set(RenderSet::Queue));
    }
}</code></pre>
<p>Back in the <code>pipeline.rs</code> file, it should be empty, so lets add another plugin to host all pipeline plugins.</p>
<pre><code class="language-rust">pub struct PipelinesPlugin;
impl Plugin for PipelinesPlugin {
    fn build(&amp;self, app: &amp;mut App) {
        let render_app = app.sub_app_mut(RenderApp);
        render_app
            .add_plugin(automata::AutomataPipelinePlugin);

        let mut render_graph = render_app.world.resource_mut::&lt;RenderGraph&gt;();
        let gol_id = render_graph.add_node("game_of_life", automata::AutomataNode::default());

        /*
         * Automata Pipeline =&gt; Camera Driver
         */
        render_graph.add_node_edge(gol_id, bevy::render::main_graph::node::CAMERA_DRIVER);
    }
}</code></pre>
<p>We are moving the render_app implementation from our <code>ShaderPlaygroundPlugin</code> to this new <code>PipelinesPlugin</code>.
Don't forget to add the <code>PipelinesPlugin</code> to the <code>ShaderPlaygroundPlugin</code> in <code>lib.rs</code>!</p>
<h2 id="camera"><a class="header" href="#camera">Camera</a></h2>
<p>Onto setting up a camera controller.</p>
<pre><code class="language-rust">const CAMERA_MOVE_SPEED: f32 = 500.0;

pub struct CameraPlugin;
impl Plugin for CameraPlugin {
    fn build(&amp;self, app: &amp;mut App) {
        app.add_system(camera_controller);
    }
}

fn camera_controller(
    time: Res&lt;Time&gt;,
    keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;,
    mut mouse_wheel_events: EventReader&lt;MouseWheel&gt;,
    mut query: Query&lt;(&amp;mut Transform, &amp;mut OrthographicProjection), With&lt;Camera&gt;&gt;,
) {
    for (mut transform, mut ortho) in query.iter_mut() {
        let up = keyboard_input.pressed(KeyCode::W);
        let down = keyboard_input.pressed(KeyCode::S);
        let left = keyboard_input.pressed(KeyCode::A);
        let right = keyboard_input.pressed(KeyCode::D);

        let x_axis = right as i8 - left as i8;
        let y_axis = up as i8 - down as i8;
        let mut move_delta = Vec2::new(x_axis as f32, y_axis as f32);

        // =========== Move the camera around =========== //
        if move_delta != Vec2::ZERO {
            move_delta /= move_delta.length();

            let z = transform.translation.z;
            transform.translation +=
                move_delta.extend(z) * CAMERA_MOVE_SPEED * time.delta_seconds();

            // Important! We need to restore the Z values when moving the camera around.
            // Bevy has a specific camera setup and this can mess with how our layers are shown.
            transform.translation.z = z;
        }

        // =========== Zoom =========== //
        for MouseWheel { x, y, unit } in mouse_wheel_events.iter() {
            let mut x_scroll_diff = 0.0;
            let mut y_scroll_diff = 0.0;

            match unit {
                MouseScrollUnit::Line =&gt; {
                    x_scroll_diff += x;
                    y_scroll_diff += y;
                }
                MouseScrollUnit::Pixel =&gt; {
                    // I just took this from three-rs, no idea why this magic number was chosen ¯\_(ツ)_/¯
                    const PIXELS_PER_LINE: f32 = 38.0;

                    y_scroll_diff += y / PIXELS_PER_LINE;
                    x_scroll_diff += x / PIXELS_PER_LINE;
                }
            }

            if x_scroll_diff != 0.0 || y_scroll_diff != 0.0 {
                if y_scroll_diff &lt; 0.0 {
                    ortho.scale *= 1.05;
                } else {
                    ortho.scale *= 1.0 / 1.05;
                }

                ortho.scale = ortho.scale.clamp(0.15, 5.);
            }
        }
    }
}
...

// in our ShaderPlaygroundPlugin

app
    // Extract the game of life image resource from the main world into the render world
    // for operation on by the compute shader and display on the sprite.
    .add_plugin(ExtractResourcePlugin::&lt;GameOfLifeImage&gt;::default())
    .add_plugin(camera::CameraPlugin)
    .add_startup_system(setup);
...</code></pre>
<p>A simple camera controller. We generate a move delta based on the pressed keys and then using bevy's builtin time resource, manipulate the
camera's position for buttery smooth movement. Adjust the movement constant to your liking. The zoom just listens for scroll events and adjusts
the orthographic projection's scale. The <code>MouseScrollUnit::Pixel</code> case is taken from an online example I found. I don't know what triggers a
<code>MouseScrollUnit::Pixel</code>, but I have only seen <code>Line</code> units so far, but better safe than sorry!</p>
<p>To better see that our camera works well, you can replace the <code>ClearColor(Color::BLACK)</code> with <code>ClearColor(Color::WHITE)</code>.
You should now be able to pan around the simulation and also zoom!</p>
<p><img src="bevy_gol_example/images/gol_camera.gif" alt="camera" /></p>
<p>The main thing I want this part to focus on would be drawing onto our canvas. We will be using <em>ANOTHER</em> ;) compute pipeline to handle this for us.
Lets setup the mouse positioning system that will be used.</p>
<p>Setting up our input bindings lets fill out <code>input.rs</code> file.</p>
<p>We need a resource to hold our mouse position, previous mouse position, and if our mouse button is down.</p>
<pre><code class="language-rust">pub struct InputPlugin;
impl Plugin for InputPlugin {
    fn build(&amp;self, app: &amp;mut App) {
        app.init_resource::&lt;AutomataParams&gt;();
    }
}

#[derive(Default, Resource, ExtractResource, Clone)]
pub struct AutomataParams {
    pub mouse_pos: Vec2,
    pub is_drawing: bool,
    pub prev_mouse_pos: Vec2,
}

pub fn update_input_state(
    window_query: Query&lt;&amp;Window&gt;,
    mut input_state: ResMut&lt;AutomataParams&gt;,
    camera_q: Query&lt;(&amp;Camera, &amp;GlobalTransform)&gt;,
    mut mouse_button_input_events: EventReader&lt;MouseButtonInput&gt;,
) {
    let Ok(primary_window) = window_query.get_single() else { return };
    // get the camera info and transform
    let Ok((camera, camera_transform)) = camera_q.get_single() else { return };

    // Determine button state
    for event in mouse_button_input_events.iter() {
        if event.button == MouseButton::Left {
            input_state.is_drawing = event.state == ButtonState::Pressed;
        }
    }
    ...
}</code></pre>
<p>Mouse button is a simple event reader. The previous and current mouse position is a bit more complicated as we need to convert from world space to canvas space.</p>
<pre><code class="language-rust">if let Some(world_position) = primary_window
    .cursor_position()
    .and_then(|cursor| camera.viewport_to_world(camera_transform, cursor))
    .map(|ray| ray.origin.truncate())
{
}</code></pre>
<p>Grabbing the world_position from the window and camera is ripped from the <a href="https://bevy-cheatbook.github.io/cookbook/cursor2world.html">bevy cheatbook</a>. Now
that we have the world coordinates, we need a way to transform them into curstor coordinates. In utils add a function:</p>
<pre><code class="language-rust">use bevy::prelude::Vec2;

pub fn world_pos_to_canvas_pos(world_pos: Vec2) -&gt; Vec2 {
    world_pos
        + Vec2::new(
            crate::SIM_SIZE.0 as f32 / 2.0,
            crate::SIM_SIZE.1 as f32 / 2.0,
        )
}</code></pre>
<p>This just takes the world position and adds half the size of the canvas to it. Finish off the input system.</p>
<pre><code class="language-rust">if let Some(world_position) = primary_window
    .cursor_position()
    .and_then(|cursor| camera.viewport_to_world(camera_transform, cursor))
    .map(|ray| ray.origin.truncate())
{
    params.prev_mouse_pos = params.mouse_pos; // NEW
    params.mouse_pos =
        crate::utils::world_pos_to_canvas_pos(world_position * Vec2::new(1.0, -1.0)); // NEW
}</code></pre>
<p><code>world_position * Vec2::new(1.0, -1.0)</code> is just flipping the y axis since images have y going down and wgpu has y going up.</p>
<p>Add the input plugin to the <code>ShaderPlaygroundPlugin</code> along with the <code>ExtractResourcePlugin</code></p>
<pre><code class="language-rust">...
.add_plugin(ExtractResourcePlugin::&lt;GameOfLifeImage&gt;::default())
.add_plugin(ExtractResourcePlugin::&lt;AutomataParams&gt;::default())
.add_plugin(camera::CameraPlugin)
.add_plugin(input::InputPlugin)
.add_plugin(pipeline::PipelinesPlugin)
.add_plugin(ui::UIPlugin)
.add_startup_system(setup);</code></pre>
<h2 id="draw-pipeline"><a class="header" href="#draw-pipeline">Draw Pipeline</a></h2>
<p>We are going to need <code>bytemuck</code> so add that to your project with <code>cargo add bytemuck</code>.</p>
<p>Add a new file in <code>pipeline</code> folder called draw. This is going to look really similar to the automata setup, just with a few minor tweaks.</p>
<pre><code class="language-rust">pub struct AutomataDrawPipelinePlugin;
impl Plugin for AutomataDrawPipelinePlugin {
    fn build(&amp;self, render_app: &amp;mut App) {
        render_app
            .init_resource::&lt;AutomataDrawPipeline&gt;()
            .add_system(queue_draw_bind_group.in_set(RenderSet::Queue));
    }
}

// ================================== Constants ================================== //

#[repr(C)]
#[derive(Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]
pub struct AutomataPushConstants {
    draw_start: [f32; 2],
    draw_end: [f32; 2],
    draw_radius: f32,
}

impl AutomataPushConstants {
    pub fn new(draw_start: Vec2, draw_end: Vec2, draw_radius: f32) -&gt; Self {
        Self {
            draw_radius,
            draw_end: draw_end.to_array(),
            draw_start: draw_start.to_array(),
        }
    }
}</code></pre>
<p>This new struct holds our push constants that we will pass to our draw pipeline shader.</p>
<blockquote>
<p>PushConstants are a way to pass data to a shader without having to create a buffer. The downside is that the data is limited and is much smaller
than the limit on buffers. The upside is that it is faster than buffers.</p>
</blockquote>
<pre><code class="language-rust">
// ================================== Pipeline ================================== //

#[derive(Resource)]
pub struct AutomataDrawPipeline {
    draw_pipeline: CachedComputePipelineId,
    draw_bind_group_layout: BindGroupLayout,
}

impl FromWorld for AutomataDrawPipeline {
    fn from_world(world: &amp;mut World) -&gt; Self {
        let pipeline_cache = world.resource::&lt;PipelineCache&gt;();

        let draw_bind_group_layout =
            world
                .resource::&lt;RenderDevice&gt;()
                .create_bind_group_layout(&amp;BindGroupLayoutDescriptor {
                    label: Some("Game of Life Bind Group Layout"),
                    entries: &amp;[BindGroupLayoutEntry {
                        binding: 0,
                        visibility: ShaderStages::COMPUTE,
                        ty: BindingType::StorageTexture {
                            access: StorageTextureAccess::ReadWrite,
                            format: TextureFormat::Rgba8Unorm,
                            view_dimension: TextureViewDimension::D2,
                        },
                        count: None,
                    }],
                });

        let brush_shader = world.resource::&lt;AssetServer&gt;().load("shaders/draw.wgsl");

        let draw_pipeline = pipeline_cache.queue_compute_pipeline(ComputePipelineDescriptor {
            shader: brush_shader,
            shader_defs: vec![],
            entry_point: Cow::from("draw"),
            layout: vec![draw_bind_group_layout.clone()],
            label: Some(std::borrow::Cow::Borrowed("Game of Life Draw Pipeline")),
            push_constant_ranges: [PushConstantRange {
                stages: ShaderStages::COMPUTE,
                range: 0..std::mem::size_of::&lt;AutomataPushConstants&gt;() as u32,
            }]
            .to_vec(),
        });

        AutomataDrawPipeline {
            draw_pipeline,
            draw_bind_group_layout,
        }
    }
}</code></pre>
<p>Our draw_pipeline has a new value: <code>push_constant_ranges</code>. The <code>push_constant_ranges</code> is a range of bytes that can be passed to the shader via <code>PushConstants</code>.</p>
<pre><code class="language-rust">// ================================== BindGroup ================================== //

#[derive(Resource)]
struct AutomataDrawBindGroup(pub BindGroup);

pub fn queue_draw_bind_group(
    mut commands: Commands,
    render_device: Res&lt;RenderDevice&gt;,
    pipeline: Res&lt;AutomataDrawPipeline&gt;,
    gpu_images: Res&lt;RenderAssets&lt;Image&gt;&gt;,
    game_of_life_image: Res&lt;GameOfLifeImage&gt;,
) {
    let view = &amp;gpu_images[&amp;game_of_life_image.0];
    let draw_bind_group = render_device.create_bind_group(&amp;BindGroupDescriptor {
        label: Some("Game of Life Draw Bind Group"),
        layout: &amp;pipeline.draw_bind_group_layout,
        entries: &amp;[BindGroupEntry {
            binding: 0,
            resource: BindingResource::TextureView(&amp;view.texture_view),
        }],
    });
    commands.insert_resource(AutomataDrawBindGroup(draw_bind_group));
}

// ================================== Nodes ================================== //
pub enum AutomataDrawState {
    Loading,
    Update,
}

pub struct AutomataDrawNode {
    state: AutomataDrawState,
}

impl Default for AutomataDrawNode {
    fn default() -&gt; Self {
        Self {
            state: AutomataDrawState::Loading,
        }
    }
}</code></pre>
<p>Our node only has two states: Loading and Update as we don't need to initialize anything.</p>
<pre><code class="language-rust">impl render_graph::Node for AutomataDrawNode {
    fn update(&amp;mut self, world: &amp;mut World) {
        let pipeline_cache = world.resource::&lt;PipelineCache&gt;();
        let pipeline = world.resource::&lt;AutomataDrawPipeline&gt;();

        // if the corresponding pipeline has loaded, transition to the next stage
        match self.state {
            AutomataDrawState::Loading =&gt; {
                if let CachedPipelineState::Ok(_) =
                    pipeline_cache.get_compute_pipeline_state(pipeline.draw_pipeline)
                {
                    self.state = AutomataDrawState::Update;
                }
            }
            AutomataDrawState::Update =&gt; {}
        }
    }

    fn run(
        &amp;self,
        _graph: &amp;mut render_graph::RenderGraphContext,
        render_context: &amp;mut RenderContext,
        world: &amp;World,
    ) -&gt; Result&lt;(), render_graph::NodeRunError&gt; {
        let params = &amp;world.resource::&lt;AutomataParams&gt;();

        if params.is_drawing {
            let texture_bind_group = &amp;world.resource::&lt;AutomataTextureBindGroup&gt;().0;
            let draw_bind_group = &amp;world.resource::&lt;AutomataDrawBindGroup&gt;().0;
            let pipeline_cache = world.resource::&lt;PipelineCache&gt;();
            let pipeline = world.resource::&lt;AutomataDrawPipeline&gt;();

            let mut pass = render_context
                .command_encoder()
                .begin_compute_pass(&amp;ComputePassDescriptor::default());

            pass.set_bind_group(0, texture_bind_group, &amp;[]);

            // select the pipeline based on the current state
            match self.state {
                AutomataDrawState::Loading =&gt; {}
                AutomataDrawState::Update =&gt; {
                    let draw_pipeline = pipeline_cache
                        .get_compute_pipeline(pipeline.draw_pipeline)
                        .unwrap();

                    let pc =
                        AutomataPushConstants::new(params.mouse_pos, params.prev_mouse_pos, 10.0);

                    pass.set_pipeline(draw_pipeline);
                    pass.set_bind_group(0, draw_bind_group, &amp;[]);
                    pass.set_push_constants(0, bytemuck::cast_slice(&amp;[pc]));
                    pass.dispatch_workgroups(
                        SIM_SIZE.0 / WORKGROUP_SIZE,
                        SIM_SIZE.1 / WORKGROUP_SIZE,
                        1,
                    );
                }
            }
        }

        Ok(())
    }
}</code></pre>
<p>Inside our run, we first check to see if we are drawing at all. If so, we pull the current mouse position as well as the previous mouse position and instantiate the <code>AutomataPushConstants</code> with a radius of 10.0.
We then setup the pipeline and add the push constants with <code>bytemuck::cast_slice</code>.</p>
<p>With that, our draw pipeline is complete and ready. Lets add it to our pipelines plugin:</p>
<pre><code class="language-rust">impl Plugin for PipelinesPlugin {
    fn build(&amp;self, app: &amp;mut App) {
        let render_app = app.sub_app_mut(RenderApp);
        render_app
            .add_plugin(draw::AutomataDrawPipelinePlugin)
            .add_plugin(automata::AutomataPipelinePlugin);

        let mut render_graph = render_app.world.resource_mut::&lt;RenderGraph&gt;();
        let gol_id = render_graph.add_node("game_of_life", automata::AutomataNode::default());
        let draw_id = render_graph.add_node("game_of_life_draw", draw::AutomataDrawNode::default());
        ...</code></pre>
<p>We now have a new node to use in our render graph! We want the <code>draw_node</code> to run  before our <code>automata_node</code>.</p>
<pre><code class="language-rust">let mut render_graph = render_app.world.resource_mut::&lt;RenderGraph&gt;();
let gol_id = render_graph.add_node("game_of_life", automata::AutomataNode::default());
let draw_id = render_graph.add_node("game_of_life_draw", draw::AutomataDrawNode::default());

/*
* Draw Pipeline =&gt; Automata Pipeline =&gt; Camera Driver
*/
render_graph.add_node_edge(draw_id, gol_id);
render_graph.add_node_edge(gol_id, bevy::render::main_graph::node::CAMERA_DRIVER);</code></pre>
<p>This creates a new edge from the <code>draw_node</code> to the <code>automata_node</code> and then from the <code>automata_node</code> to the <code>camera_driver</code>! Onto the draw shader!!</p>
<h2 id="draw-shader"><a class="header" href="#draw-shader">Draw Shader</a></h2>
<p>create a file called <code>draw.wgsl</code> in our <code>shaders</code> folder and add the following starter code:</p>
<pre><code class="language-glsl">struct PushConstants {
    draw_start: vec2&lt;f32&gt;,
    draw_end: vec2&lt;f32&gt;,
    draw_radius: f32,
}
var&lt;push_constant&gt; pc: PushConstants;

@group(0) @binding(0)
var texture: texture_storage_2d&lt;rgba8unorm, read_write&gt;;

@compute @workgroup_size(8, 8, 1)
fn draw(@builtin(global_invocation_id) invocation_id: vec3&lt;u32&gt;)
{
    let pixel = vec2&lt;u32&gt;(invocation_id.xy);
    let size = vec2&lt;u32&gt;(textureDimensions(texture));
    if (pixel.x &gt;= size.x &amp;&amp; pixel.y &gt;= size.y) {
        return ;
    }

    // Draw circle
    if (pc.draw_radius &gt; 0.0) {

    }
}
</code></pre>
<p>This is all familiar except for the new push_contant and a new function: <code>textureDimensions</code>. The <code>push_contant</code> variable should match what we are passing from
rust side of things. We are passing in the start and end of the mouse position as well as the radius of the circle we want to draw.</p>
<p><code>textureDimensions</code> function returns the dimensions of the texture we are sampling from.We use this to check if the current pixel is outside of the texture
bounds.</p>
<p>Now we pass in a <code>start</code> and <code>end</code> position, so we need to generate a line between these two points. Searching the web I found the following stackoverflow
thread with many examples: <a href="https://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment">shortest-distance-between-a-point-and-a-line-segment</a></p>
<pre><code class="language-glsl">// Line v-&gt;w, point p
// https://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment
fn closest_point_on_line(v: vec2&lt;f32&gt;, w: vec2&lt;f32&gt;, p: vec2&lt;f32&gt;) -&gt; vec2&lt;f32&gt; {
    let c = v - w;

    // length squared
    let l2 = dot(c, c);
    if (l2 == 0.0) {
        return v;
    }

    let t = max(0.0, min(1.0, dot(p - v, w - v) / l2));
    let projection = v + t * (w - v);
    return projection;
}
</code></pre>
<blockquote>
<p>Challenge: Feel free to scower the web for your own implementation and try replacing my implementation with yours!</p>
</blockquote>
<p>Using this in our <code>draw</code> function:</p>
<pre><code class="language-glsl">// Draw circle
    if (pc.draw_radius &gt; 0.0) {
        let pos = vec2&lt;f32&gt;(pixel);
        let point_on_line = closest_point_on_line(pc.draw_start, pc.draw_end, pos);
    }
</code></pre>
<p>We need to cast our <code>pixel</code> variable to an f32 to be used by our <code>closest_point_on_line</code> function. We can now use this point to draw with. Add a new function
for drawing a circle:</p>
<pre><code class="language-glsl">fn draw_particle_circle(pos: vec2&lt;f32&gt;, draw_pos: vec2&lt;f32&gt;, radius: f32) {
    let y_start = draw_pos.y - radius;
    let y_end = draw_pos.y + radius;
    let x_start = draw_pos.x - radius;
    let x_end = draw_pos.x + radius;
    if (pos.x &gt;= x_start &amp;&amp; pos.x &lt;= x_end &amp;&amp; pos.y &gt;= y_start &amp;&amp; pos.y &lt;= y_end) {
        let diff = pos - draw_pos;
        let dist = length(diff);
        if (round(dist) &lt;= radius) {
            textureStore(texture, vec2&lt;i32&gt;(pos), vec4&lt;f32&gt;(1.0, 1.0, 1.0, 1.0));
        }
    }
}
</code></pre>
<p>This looks pretty similar to how you would draw a circle on the rust side. We create a bounding box based on the radius and make sure our click position
falls within that box. If it does, we calculate the distance from the click position to the current pixel and if that distance is less than or equal to
the radius, we store an alive cell at that position. (remember our alive cells are marked by a 1.0 value in the r channel of the pixel color).</p>
<p>Finish off our shader:</p>
<pre><code class="language-glsl">// Draw circle
if (pc.draw_radius &gt; 0.0) {
    let pos = vec2&lt;f32&gt;(pixel);
    let point_on_line = closest_point_on_line(pc.draw_start, pc.draw_end, pos);
    draw_particle_circle(pos, point_on_line, pc.draw_radius);
}
</code></pre>
<h2 id="complete"><a class="header" href="#complete">Complete</a></h2>
<p>Running the example you should be able to draw on the simulation with your mouse:</p>
<p><img src="bevy_gol_example/images/gol_4_drawing.gif" alt="drawing" /></p>
<h2 id="bonus"><a class="header" href="#bonus">Bonus</a></h2>
<p>One thing you might notice is our simulation doesn't wrap between the edges. We can fix this by manipulating our <code>game_of_life.wgsl</code> slightly.
In the <code>is_alive</code> function we can add the following:</p>
<pre><code class="language-glsl">fn is_alive(location: vec2&lt;i32&gt;, offset_x: i32, offset_y: i32) -&gt; u32 {
    let size = vec2&lt;i32&gt;(textureDimensions(texture));
    var loc = ((location + vec2&lt;i32&gt;(offset_x, offset_y)) + size) % size;
    let value: vec4&lt;f32&gt; = textureLoad(texture, loc);
    return u32(value.x);
}
</code></pre>
<p>I broke out the calculations onto multiple lines for readability. We first get the dimensions of the texture we are sampling from. We then add the offset
to the current location, add the size to that result and finally mod the result by the size. This will wrap the edges of the texture both x and y.</p>
<p>With that, our cells will now wrap around the edges of the simulation! Awesome!</p>
<blockquote>
<p>Challenge: Create a method to draw a square instead of a circle. For even more complexity, you can add a push_constant bool to pass in
whether you want to draw a circle or a square.</p>
</blockquote>
<p>Code can be found on github: <a href="https://github.com/bayou-brogrammer/bevy_shader_playground/tree/explore_part4/sims/game_of_life_sim/src">Part 4</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bevy-game-of-life-shader-example-part-5"><a class="header" href="#bevy-game-of-life-shader-example-part-5">Bevy Game of Life Shader Example Part 5</a></h1>
<h2 id="square-challenge"><a class="header" href="#square-challenge">Square Challenge</a></h2>
<details>
<summary>Spoiler warning</summary>
<p>In the past tutorial, I challenged you to draw a square instead of a circle. Let's see how your implementation compares to mine.</p>
<pre><code class="language-glsl">fn draw_particle_square(pos: vec2&lt;f32&gt;, draw_pos: vec2&lt;f32&gt;, size: f32)  {
    let y_start = draw_pos.y - size / 2.;
    let y_end = draw_pos.y + size / 2.;
    let x_start = draw_pos.x - size / 2.;
    let x_end = draw_pos.x + size / 2.;
    if (pos.x &gt;= x_start &amp;&amp; pos.x &lt;= x_end &amp;&amp; pos.y &gt;= y_start &amp;&amp; pos.y &lt;= y_end) {
        textureStore(texture, vec2&lt;i32&gt;(pos), vec4&lt;f32&gt;(1.0, 1.0, 1.0, 1.0));
    }
}
</code></pre>
</details>
<h2 id="quick-renames"><a class="header" href="#quick-renames">Quick Renames</a></h2>
<p>If you previous completed part_4, I changed <code>InputState</code> =&gt; <code>AutomataParams</code>.</p>
<h2 id="ui"><a class="header" href="#ui">UI</a></h2>
<p>Before we continue with the graphical side of things, let's add some UI to our game. I prefer to use <a href="https://github.com/emilk/egui">egui</a> in my projects, and there is a wonderful
integration crate for bevy <a href="https://github.com/mvlabat/bevy_egui">bevy_egui</a>. Let's add it to our project.</p>
<blockquote>
<p>$ <code>cargo add bevy_egui</code></p>
</blockquote>
<p>Our UI will be pretty simplicstic for now. We will show the base simulation properties, and a couple of overridable properties. We are going to quickly
add some new properties that we will use.</p>
<pre><code class="language-rust">pub struct AutomataParams {
    pub is_paused: bool, // NEW
    pub is_drawing: bool,
    pub can_scroll: bool, // NEW
    pub use_square_brush: bool, // NEW

    pub radius: f32, // NEW
    pub mouse_pos: Vec2,
    pub prev_mouse_pos: Vec2,
}

impl Default for AutomataParams {
    fn default() -&gt; Self {
        Self {
            is_paused: false, // NEW
            can_scroll: true, // NEW
            is_drawing: false,
            use_square_brush: true, // NEW

            radius: 4.0, // NEW
            mouse_pos: Vec2::ZERO,
            prev_mouse_pos: Vec2::ZERO,
        }
    }
}</code></pre>
<p>Now lets build our UI!</p>
<pre><code class="language-rust">const SPACING: f32 = 10.0;
const TEXT_SIZE: f32 = 15.0;
const HEADING_SIZE: f32 = 20.0;

#[bevy_plugin]
pub fn UIPlugin(app: &amp;mut App) {
    app.add_plugin(EguiPlugin).add_system(user_interface); // Remember to add the EguiPlugin
}

/// Give our text a custom size
fn sized_text(ui: &amp;mut Ui, text: impl Into&lt;String&gt;) {
    ui.label(
        egui::RichText::new(text)
            .size(TEXT_SIZE)
            .color(egui::Color32::WHITE),
    );
}

fn heading(ui: &amp;mut Ui, text: impl Into&lt;String&gt;) {
    ui.heading(
        egui::RichText::new(text)
            .underline()
            .size(HEADING_SIZE)
            .color(egui::Color32::WHITE),
    );
}</code></pre>
<p>I am adding a couple of helper methods just to make things easier and reduce the boilerplate I have to write later :D</p>
<pre><code class="language-rust">/// System to generate user interface with egui
pub fn user_interface(
    mut contexts: EguiContexts,
    mut params: ResMut&lt;AutomataParams&gt;,
) {
    egui::Window::new("Automata")
        .constrain(true)
        .fixed_pos(egui::pos2(10.0, 10.0))
        .show(contexts.ctx_mut(), |ui| {
            ui.visuals_mut().override_text_color = Some(egui::Color32::WHITE);

            heading(ui, "Info");
            ui.add_space(SPACING);

            sized_text(ui, format!("Grid size: ({},{})", SIM_SIZE.0, SIM_SIZE.1));

            sized_text(
                ui,
                (if params.is_paused {
                    "Paused"
                } else {
                    "Simulating"
                })
                .to_string(),
            );

            ui.add_space(SPACING);
            heading(ui, "Settings");
            ui.add_space(SPACING);

            ui.checkbox(&amp;mut params.use_square_brush, "Square Brush");
            ui.add(egui::Slider::new(&amp;mut params.radius, 1.0..=200.0).text("Brush Size"));
        });
}
</code></pre>
<p>Our <code>Info</code> section will show the size of our grid, and if our simulation is currently running. The <code>Settings</code> section will
allow us to change the brush size and toggle between a square brush or circular brush.</p>
<p>Add the plugin to our main plugin, and run the application. This is how it looks:</p>
<p><img src="bevy_gol_example/images/ui_display_1.png" alt="UI" /></p>
<p>Let's hookup these properties to our application so we can actually use them!!</p>
<p>In our <code>update_input_state</code> system, we need to check if Egui is currently being hovered, or capturing the mouse. If so, we need to disable certain inputs
from happening while the UI is <code>active</code>.</p>
<pre><code class="language-rust">pub fn update_input_state(
    mut contexts: EguiContexts,
    window_query: Query&lt;&amp;Window&gt;,
    mut params: ResMut&lt;AutomataParams&gt;,
    keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;,
    camera_q: Query&lt;(&amp;Camera, &amp;GlobalTransform)&gt;,
    mut mouse_button_input_events: EventReader&lt;MouseButtonInput&gt;,
) {
    let Ok(primary_window) = window_query.get_single() else { return };
    // get the camera info and transform
    let Ok((camera, camera_transform)) = camera_q.get_single() else { return };

    let ctx = contexts.ctx_mut();
    if ctx.wants_pointer_input()
        || ctx.is_pointer_over_area()
        || ctx.is_using_pointer()
        || ctx.wants_pointer_input()
    {
        // GUI gets priority input
        params.is_drawing = false;
        params.can_scroll = false;
        return;
    } else {
        params.can_scroll = true;
    }
...</code></pre>
<p>Essentiall, if the UI is currently using the mouse, we don't want to allow the user to draw on the grid, or scroll the camera.</p>
<p>Now we can hookup our <code>is_paused</code> property to our simulation. We will do this in the <code>update_simulation</code> system.</p>
<pre><code class="language-rust">...
// Pause the simulation
if keyboard_input.just_pressed(KeyCode::Space) {
    params.is_paused = !params.is_paused;
}
...</code></pre>
<p>Feel free to use whatever KeyCode you wish, but we just flip the simulation run state when the user presses the spacebar.</p>
<p>Quickly flipping to our <code>camera_controller</code> system, we can disable scroll events based on our new property.</p>
<pre><code class="language-rust">pub fn camera_controller(
    time: Res&lt;Time&gt;,
    params: Res&lt;AutomataParams&gt;, // NEW
    keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;,
    mut mouse_wheel_events: EventReader&lt;MouseWheel&gt;,
    mut query: Query&lt;(&amp;mut Transform, &amp;mut OrthographicProjection), With&lt;Camera&gt;&gt;,
)
...
// =========== Zoom =========== //
if params.can_scroll { // NEW
    // zoom code
}</code></pre>
<p>In our automata pipeline, we can disable the pipeline if the simulation is paused.</p>
<pre><code class="language-rust">fn run(
    &amp;self,
    _graph: &amp;mut render_graph::RenderGraphContext,
    render_context: &amp;mut RenderContext,
    world: &amp;World,
) -&gt; Result&lt;(), render_graph::NodeRunError&gt; {
    let is_paused = &amp;world.resource::&lt;AutomataParams&gt;().is_paused;

    if !is_paused {
        // run the init / update pipelines
    }

    Ok(())
}</code></pre>
<p>And finally, we can use the two new params in our <code>AutomataPushConstants</code> for our <code>draw_pipeline</code>.</p>
<pre><code class="language-rust">pub struct AutomataPushConstants {
    draw_start: [f32; 2],
    draw_end: [f32; 2],
    draw_radius: f32,
    draw_square: u32, // NEW
}

impl AutomataPushConstants {
    pub fn new(draw_start: Vec2, draw_end: Vec2, draw_radius: f32, draw_square: bool) -&gt; Self {
        Self {
            draw_radius,
            draw_end: draw_end.to_array(),
            draw_square: draw_square as u32,  // NEW
            draw_start: draw_start.to_array(),
        }
    }
}

...

let pc = AutomataPushConstants::new(
    params.mouse_pos,
    params.prev_mouse_pos,
    params.radius, // NEW
    params.use_square_brush, // NEW
);
...</code></pre>
<p>Currently, there is no bool type for <code>push_constants</code> so a <code>u32</code> will have to do.</p>
<p>To finish up our integrations, we need to fix our <code>draw.wgsl</code> to use the new <code>draw_square</code> property.</p>
<pre><code class="language-glsl">struct PushConstants {
    draw_start: vec2&lt;f32&gt;,
    draw_end: vec2&lt;f32&gt;,
    draw_radius: f32,
    draw_square: u32,
}
var&lt;push_constant&gt; pc: PushConstants;

...

fn draw_particle_square(pos: vec2&lt;f32&gt;, draw_pos: vec2&lt;f32&gt;, size: f32)  {
    let y_start = draw_pos.y - size / 2.;
    let y_end = draw_pos.y + size / 2.;
    let x_start = draw_pos.x - size / 2.;
    let x_end = draw_pos.x + size / 2.;
    if (pos.x &gt;= x_start &amp;&amp; pos.x &lt;= x_end &amp;&amp; pos.y &gt;= y_start &amp;&amp; pos.y &lt;= y_end) {
        aliveDts[idx(vec2&lt;i32&gt;(pos))] = new_cell(true);
    }
}

if (pc.draw_radius &gt; 0.0) {
    let pos = vec2&lt;f32&gt;(pixel);
    let point_on_line = closest_point_on_line(pc.draw_start, pc.draw_end, pos);

    // NEW BLOCK
    if (bool(pc.draw_square)){
        draw_particle_square(pos, point_on_line, pc.draw_radius);
    }else{
        draw_particle_circle(pos, point_on_line, pc.draw_radius);
    }
}
</code></pre>
<p>Running our simulation now: We can see the UI is working as expected! We can change the radius, and even pause the simulation with <code>Space</code>.</p>
<p><img src="bevy_gol_example/images/ui_display_2.gif" alt="UI" /></p>
<p>Whew that was alot, but we have a working UI now! I now want to explore another feature of wgpu, <code>buffers</code>. Currently, we have been storing
all of our cell data as colors in our texture, but what if we wanted to store more data? We could use different values within the color channels,
but that would get messy quickly and would also be hard to track, instead we are going to store our cells in <code>buffers</code> and use the buffers to
paint to the texture.</p>
<h2 id="buffers"><a class="header" href="#buffers">Buffers</a></h2>
<blockquote>
<p>A buffer is a blob of data on the GPU. A buffer is guaranteed to be contiguous, meaning that all the data is stored
sequentially in memory. Buffers are generally used to store simple things like structs or arrays, but they can store
more complex stuff such as graph structures like trees (provided all the nodes are stored together and don't reference anything outside of the buffer)</p>
</blockquote>
<p>To get started, we are going to add a <code>Uniform</code> buffer for our simulation size, instead of querying the texture each time. This is a pretty simplicstic
example for a uniform buffer, but it will help us understand the basics.</p>
<h3 id="uniform-buffers"><a class="header" href="#uniform-buffers">Uniform Buffers</a></h3>
<blockquote>
<p>A uniform is a blob of data that is available to every invocation of a set of shaders.
We've technically already used uniforms for our texture and sampler.
Uniform buffers are great for small, read only data</p>
</blockquote>
<p>Add a helper method to our <code>utils.rs</code> file:</p>
<pre><code class="language-rust">pub fn create_uniform_buffer&lt;T: bytemuck::Pod + bytemuck::Zeroable&gt;(
    device: &amp;RenderDevice,
    data: &amp;[T],
    label: Option&lt;&amp;str&gt;,
) -&gt; Buffer {
    device.create_buffer_with_data(&amp;BufferInitDescriptor {
        label,
        contents: bytemuck::cast_slice(data),
        usage: BufferUsages::UNIFORM | BufferUsages::COPY_DST,
    })
}</code></pre>
<p>We using our handy dandy <code>RenderDevice</code> to create a buffer with initial data. The contents has to be <code>&amp;[u8]</code> so we use bytemuck to cast our data to bytes.
Notice the buffer usage. <code>UNIFORM</code> because this will be a uniform buffer and <code>COPY_DST</code> allows a buffer to be the destination buffer for
a <code>CommandEncoder::copy_buffer_to_buffer</code>, <code>CommandEncoder::copy_texture_to_buffer</code>, <code>CommandEncoder::clear_buffer</code> or <code>Queue::write_buffer</code> operation.</p>
<p>Over in our <code>setup</code> system where we create our image, lets also add our buffers.</p>
<pre><code class="language-rust">// NEW
#[derive(Resource, Clone, ExtractResource)]
pub struct GameOfLifeBuffers {
    pub uniform_buffer: Buffer,
}

fn setup(mut commands: Commands, mut images: ResMut&lt;Assets&lt;Image&gt;&gt;, device: Res&lt;RenderDevice&gt;) {
    ...
    let uniform_size_buffer = utils::create_uniform_buffer(
        &amp;device,
        &amp;[SIM_SIZE.0, SIM_SIZE.1],
        Some("Simulation Size Uniform"),
    );

    commands.spawn(Camera2dBundle::default());
    commands.insert_resource(GameOfLifeImage(image));

    // NEW
    commands.insert_resource(GameOfLifeBuffers {
        uniform_buffer: uniform_size_buffer, 
    });
}</code></pre>
<p>Using our helper method, we create a buffer with two <code>u32</code> values: <code>sim_width</code> and <code>sim_height</code> and insert it into our resources.
As previously where we had to tell our pipeline about the entire layout, we need to add the uniform buffer description as well.</p>
<p>Remember to add the <code>ExtractResourcePlugin</code> to the main plugin:</p>
<pre><code class="language-rust">.add_plugin(ExtractResourcePlugin::&lt;GameOfLifeBuffers&gt;::default())</code></pre>
<p>Starting with <code>AutomataPipeline</code> in the <code>FromWorld</code> implementation:</p>
<pre><code class="language-rust">.create_bind_group_layout(&amp;BindGroupLayoutDescriptor {
    label: Some("Game of Life Bind Group Layout"),
    entries: &amp;[
        BindGroupLayoutEntry {
            binding: 0,
            count: None,
            visibility: ShaderStages::COMPUTE,
            ty: BindingType::Buffer {
                ty: BufferBindingType::Uniform,
                has_dynamic_offset: false,
                min_binding_size: BufferSize::new(
                    (2 * std::mem::size_of::&lt;u32&gt;()) as _,
                ),
            },
        },
        BindGroupLayoutEntry {
            binding: 1,
            visibility: ShaderStages::COMPUTE,
            ty: BindingType::StorageTexture {
                access: StorageTextureAccess::ReadWrite,
                format: TextureFormat::Rgba8Unorm,
                view_dimension: TextureViewDimension::D2,
            },
            count: None,
        },
    ],
});</code></pre>
<p>We are setting our uniform buffer as the first binding, this is important because changing our layout will have to also be reflected in the <code>BindGroup</code> and
related shader. The entry type is <code>BufferBindingType::Uniform</code> and we set the <code>min_binding_size</code> to the size of <code>2</code> <code>u32</code> values.</p>
<p>Then in our <code>bind_group</code> creation:</p>
<pre><code class="language-rust">let bind_group = render_device.create_bind_group(&amp;BindGroupDescriptor {
    label: Some("Game of Life Bind Group"),
    layout: &amp;pipeline.texture_bind_group_layout,
    entries: &amp;[
        BindGroupEntry {
            binding: 0,
            resource: buffers.uniform_buffer.as_entire_binding(),
        },
        BindGroupEntry {
            binding: 1,
            resource: BindingResource::TextureView(&amp;view.texture_view),
        },
    ],
});</code></pre>
<p>Finally we can modify our shader to intake this new layout:</p>
<pre><code class="language-glsl">// game_of_life.wgsl

@group(0) @binding(0) 
var&lt;uniform&gt; size : vec2&lt;u32&gt;; // width, height
@group(0) @binding(1)
var texture: texture_storage_2d&lt;rgba8unorm, read_write&gt;;

...

fn is_alive(location: vec2&lt;i32&gt;, offset_x: i32, offset_y: i32) -&gt; u32 {
    var loc = ((location + vec2&lt;i32&gt;(offset_x, offset_y)) + vec2&lt;i32&gt;(size)) % vec2&lt;i32&gt;(size);
    let value: vec4&lt;f32&gt; = textureLoad(texture, loc);
    return u32(value.x);
}
</code></pre>
<p>Our uniform is a <code>vec2&lt;u32&gt;</code>, for width/height, and we can now replaced our previous calls with <code>textureDimensions</code> with <code>size</code>.</p>
<blockquote>
<p>Challenge: Can you add the uniform buffer to the draw pipeline and use it within the shader?</p>
</blockquote>
<details>
<summary>Challenge Spoiler</summary>
<p>Adding the uniform to the draw pipeline is exactly the same as the compute pipeline. This is the resulting shader code from the buffer:</p>
<pre><code class="language-glsl">@compute @workgroup_size(8, 8, 1)
fn draw(@builtin(global_invocation_id) invocation_id: vec3&lt;u32&gt;)
{
    let pixel = vec2&lt;u32&gt;(invocation_id.xy);
    if (pixel.x &gt;= size.x &amp;&amp; pixel.y &gt;= size.y) { // NEW
        return ;
    }

    if (pc.draw_radius &gt; 0.0) {
        let pos = vec2&lt;f32&gt;(pixel);
        let point_on_line = closest_point_on_line(pc.draw_start, pc.draw_end, pos);

        if (bool(pc.draw_square)){
            draw_particle_square(pos, point_on_line, pc.draw_radius);
        }else{
            draw_particle_circle(pos, point_on_line, pc.draw_radius);
        }
    }
}
</code></pre>
<p>Review the <a href="https://github.com/bayou-brogrammer/bevy_shader_playground/blob/explore_part5/sims/game_of_life_sim/src/pipeline/draw.rs">source</a> for the full implementation.</p>
</details>
<h3 id="storage-buffers"><a class="header" href="#storage-buffers">Storage Buffers</a></h3>
<blockquote>
<p>Storage buffers are usually slightly slower than uniform buffers, but they can be much, much bigger. They can be read or written to.
They are useful for storing large amounts of data that is read or written to by shaders.</p>
</blockquote>
<p>We are going to use <code>StorageBuffers</code> to store our cell data. Now before we start creating and hooking up our storage buffer, I want to explain the reasoning
for switching to a storage buffer. Previously we were using a <code>Texture2d</code> to store our cell data. This was great for single value fields, but I want
to store more data per cell, specifically, I want to allow for the simulation to have a heat map based on cell state.\</p>
<pre><code class="language-rust">sturct Cell{
    alive: u32,
    heat: f32,
}</code></pre>
<p>This will be the struct inside our shader, so lets keep that in mind when creating the buffers. Let's add another helper method to our <code>utils</code> module:</p>
<pre><code class="language-rust">pub fn create_storage_buffer_with_data&lt;T: bytemuck::Pod + bytemuck::Zeroable&gt;(
    device: &amp;RenderDevice,
    data: &amp;[T],
    label: Option&lt;&amp;str&gt;,
) -&gt; Buffer {
    device.create_buffer_with_data(&amp;BufferInitDescriptor {
        label,
        contents: bytemuck::cast_slice(data),
        usage: BufferUsages::STORAGE | BufferUsages::COPY_DST,
    })
}</code></pre>
<p>Same as our uniform buffer, but this time we are using <code>BufferUsages::STORAGE</code>.</p>
<p>Then in our setup:</p>
<pre><code class="language-rust">#[derive(Resource, Clone, ExtractResource)]
pub struct GameOfLifeBuffers {
    pub uniform_buffer: Buffer,
    pub in_out_buffers: Vec&lt;Buffer&gt;, // NEW
}

...

// We multiply by 2 because we need to store `alive` and `heat` data for each cell.
let initial_life_data = vec![0u32; 2 * NUM_OF_CELLS];
let buffers = (0..2)
    .map(|i| {
        utils::create_storage_buffer_with_data(
            &amp;device,
            &amp;initial_life_data,
            Some(&amp;format!("Game of Life Buffer {i}")),
        )
    })
    .collect::&lt;Vec&lt;_&gt;&gt;();

commands.spawn(Camera2dBundle::default());
commands.insert_resource(GameOfLifeImage(image));
commands.insert_resource(GameOfLifeBuffers {
    in_out_buffers: buffers, // NEW!!
    uniform_buffer: uniform_size_buffer,
});</code></pre>
<p>First thing you probably notice is that we are adding two buffers. The reason for this is we are going to use the <code>ping-pong</code> technique to swap between
buffers. This is a common technique used in graphics programming. We will be using one buffer to read from and one buffer to write to. Then we will
swap the buffers and repeat.</p>
<p>You can determine the state of each cell by its neighbors, then write the new state to an output buffer, and repeat each frame
swapping the output buffer to be the new input. Each pixel calculation can be done independently of each other despite the neighbor relations.
Or a fractal. These are what you'd call <a href="https://en.wikipedia.org/wiki/Embarrassingly_parallel">embarrassingly parallel</a>. We want that.</p>
<blockquote>
<ol>
<li>Read Buffer Input</li>
<li>Determine new state</li>
<li>Write Buffer Output</li>
<li>Swap Buffer Input and Buffer Output
Repeat</li>
</ol>
</blockquote>
<p>To flip the input buffer with the ouput buffer, we are going to keep track of a simple frame counter and just modulo it by 2.</p>
<pre><code class="language-rust">pub struct AutomataParams {
    pub is_paused: bool,
    pub is_drawing: bool,
    pub can_scroll: bool,
    pub use_square_brush: bool,

    pub radius: f32,
    pub mouse_pos: Vec2,
    pub prev_mouse_pos: Vec2,
    pub frame: Arc&lt;Mutex&lt;usize&gt;&gt;, /// NEW
}</code></pre>
<p>Now why an <code>Arc&lt;Mutex&gt;</code>? Because our AutomataParams exist within the main world, and are copied into the render world each frame, we have no way to get
changes back to the main world, if we manipulated the <code>frame</code> directly. So we are going to use an <code>Arc&lt;Mutex&gt;</code> to share the frame counter between the
main world and the render world.</p>
<p>Then again starting with our <code>AutomataPipeline</code>:</p>
<pre><code class="language-rust">...

const NUM_OF_CELLS: usize = (SIM_SIZE.0 * SIM_SIZE.1) as usize;

...

.create_bind_group_layout(&amp;BindGroupLayoutDescriptor {
    label: Some("Game of Life Bind Group Layout"),
    entries: &amp;[
        BindGroupLayoutEntry {
            binding: 0,
            count: None,
            visibility: ShaderStages::COMPUTE,
            ty: BindingType::Buffer {
                ty: BufferBindingType::Uniform,
                has_dynamic_offset: false,
                min_binding_size: BufferSize::new(
                    (2 * std::mem::size_of::&lt;u32&gt;()) as _,
                ),
            },
        },
        BindGroupLayoutEntry { // NEW
            binding: 1,
            count: None,
            visibility: ShaderStages::COMPUTE,
            ty: BindingType::Buffer {
                ty: BufferBindingType::Storage { read_only: false },
                has_dynamic_offset: false,
                min_binding_size: BufferSize::new(
                    (2 * NUM_OF_CELLS * std::mem::size_of::&lt;u32&gt;()) as _,
                ),
            },
        },
        BindGroupLayoutEntry { // NEW
            binding: 2,
            count: None,
            visibility: ShaderStages::COMPUTE,
            ty: BindingType::Buffer {
                ty: BufferBindingType::Storage { read_only: false },
                has_dynamic_offset: false,
                min_binding_size: BufferSize::new(
                    (2 * NUM_OF_CELLS * std::mem::size_of::&lt;u32&gt;()) as _,
                ),
            },
        },
        BindGroupLayoutEntry {
            binding: 3,
            visibility: ShaderStages::COMPUTE,
            ty: BindingType::StorageTexture {
                access: StorageTextureAccess::ReadWrite,
                format: TextureFormat::Rgba8Unorm,
                view_dimension: TextureViewDimension::D2,
            },
            count: None,
        },
    ],
});

...


pub fn queue_automata_bind_group(
    mut commands: Commands,
    render_device: Res&lt;RenderDevice&gt;,

    params: Res&lt;AutomataParams&gt;,
    buffers: Res&lt;GameOfLifeBuffers&gt;,
    game_of_life_image: Res&lt;GameOfLifeImage&gt;,

    pipeline: Res&lt;AutomataPipeline&gt;,
    gpu_images: Res&lt;RenderAssets&lt;Image&gt;&gt;,
) {
    let view = &amp;gpu_images[&amp;game_of_life_image.0];

    // NEW!!!
    let (buffer_src, buffer_dst) = if *params.frame.lock() % 2 == 0 {
        (&amp;buffers.in_out_buffers[0], &amp;buffers.in_out_buffers[1])
    } else {
        (&amp;buffers.in_out_buffers[1], &amp;buffers.in_out_buffers[0])
    };

    let bind_group = render_device.create_bind_group(&amp;BindGroupDescriptor {
        label: Some("Game of Life Bind Group"),
        layout: &amp;pipeline.texture_bind_group_layout,
        entries: &amp;[
            BindGroupEntry {
                binding: 0,
                resource: buffers.uniform_buffer.as_entire_binding(),
            },
            BindGroupEntry {
                binding: 1,
                resource: buffer_src.as_entire_binding(), // NEW
            },
            BindGroupEntry {
                binding: 2,
                resource: buffer_dst.as_entire_binding(), // NEW
            },
            BindGroupEntry {
                binding: 3,
                resource: BindingResource::TextureView(&amp;view.texture_view),
            },
        ],
    });
...</code></pre>
<p>Our storage type is <code>read_only: false</code> because we are going to be writing to it and our <code>min_binding_size</code> is the size of 2 <code>u32</code> multiplied by
the number of cells. We use the <code>frame</code> property to swap the buffers each frame so that our input buffer becomes out output buffer and vice versa.</p>
<p>Now in our <code>AutomataNode</code> implementation, let's update the <code>update</code> fn to update the frame each time:</p>
<pre><code class="language-rust">fn update(&amp;mut self, world: &amp;mut World) {
    let pipeline = world.resource::&lt;AutomataPipeline&gt;();
    let pipeline_cache = world.resource::&lt;PipelineCache&gt;();

    // if the corresponding pipeline has loaded, transition to the next stage
    match self.state {
        AutomataState::Loading =&gt; {
            if let CachedPipelineState::Ok(_) =
                pipeline_cache.get_compute_pipeline_state(pipeline.init_pipeline)
            {
                self.state = AutomataState::Init;
            }
        }
        AutomataState::Init =&gt; {
            if let CachedPipelineState::Ok(_) =
                pipeline_cache.get_compute_pipeline_state(pipeline.update_pipeline)
            {
                self.state = AutomataState::Update;
            }
        }
        AutomataState::Update =&gt; {
            // NEW!!
            let params = world.resource_mut::&lt;AutomataParams&gt;();
            if !params.is_paused {
                *params.frame.lock() += 1;
            }
        }
    }
}</code></pre>
<p>Our shaders are going to start sharing similar properties, so lets create a core shader module to be imported into our main shaders:</p>
<p>Create a top level folder call <code>shaders</code> and add a file called <code>core.wgsl</code>.</p>
<pre><code class="language-glsl">#define_import_path bevy_shader_playground::core

struct Cell{
    alive: u32,
    heat: u32,
};

struct PushConstants {
    draw_start: vec2&lt;f32&gt;,
    draw_end: vec2&lt;f32&gt;,
    draw_radius: f32,
    draw_square: u32,
}
var&lt;push_constant&gt; pc: PushConstants;

fn idx(location: vec2&lt;i32&gt;) -&gt; i32 {
    return location.y * i32(size.x) + location.x;
}

fn new_cell(alive: bool) -&gt; Cell {
    return Cell(u32(alive), 0u);
}
</code></pre>
<p>We are moving our push_constants struct into this module and adding a new struct called <code>Cell</code> which will be used to represent our cells in our buffers.
We are also adding a couple helper functions. The <code>idx</code> function will be used to convert our 2d coordinates into a 1d index since our buffers are 1d arrays.
The <code>new_cell</code> helps generate new <code>Cells</code> with a zero heat value.</p>
<p>WebGPU doesn't have the concept of importing other shaders, so this is a bevy specfiic feature. So we need to register our internal shader, so that bevy
knows how to handle our import maps. In our <code>pipeline.rs</code> file inside our plugin:</p>
<pre><code class="language-rust">pub const SHADER_CORE: HandleUntyped =
    HandleUntyped::weak_from_u64(Shader::TYPE_UUID, 1371231089456109822);

pub struct PipelinesPlugin;
impl Plugin for PipelinesPlugin {
    fn build(&amp;self, app: &amp;mut App) {
        load_internal_asset!(app, SHADER_CORE, "shaders/core.wgsl", Shader::from_wgsl);
...</code></pre>
<p>Here we are registering our <code>core</code> shader so that we can import it in our main shaders! That wraps up the rust porting,
now in our <code>game_of_life.wgsl</code> lets add the new layout.</p>
<pre><code class="language-glsl">#import bevy_shader_playground::core

@group(0) @binding(0) 
var&lt;uniform&gt; size : vec2&lt;u32&gt;; // width, height
@group(0) @binding(1) 
var&lt;storage, read_write&gt; aliveSrc : array&lt;Cell&gt;;
@group(0) @binding(2) 
var&lt;storage, read_write&gt; aliveDts : array&lt;Cell&gt;;
@group(0) @binding(3)
var texture: texture_storage_2d&lt;rgba8unorm, read_write&gt;;

fn get_cell(location: vec2&lt;i32&gt;) -&gt; Cell {
    return aliveSrc[idx(location)];
}

...
</code></pre>
<p>We import our core module to get access to the <code>Cell</code> struct. We are adding two new <code>read_write</code> (this matches the bindings!) buffers of <code>Cell</code>.
I added a <code>get_cell</code> helper function just to cut down on boilerplate a bit. To fix our <code>init</code> function, we just need to replace the <code>textureStore</code> call
with inserting a new cell into our <code>aliveSrc</code> buffer:</p>
<pre><code class="language-glsl">@compute @workgroup_size(8, 8, 1)
fn init(@builtin(global_invocation_id) invocation_id: vec3&lt;u32&gt;, @builtin(num_workgroups) num_workgroups: vec3&lt;u32&gt;) {
    let location = vec2&lt;i32&gt;(invocation_id.xy);

    let randomNumber = randomFloat(invocation_id.y * num_workgroups.x + invocation_id.x);
    let alive = randomNumber &gt; 0.9;
    aliveSrc[idx(location)] = new_cell(alive); // NEW!!
}
</code></pre>
<p>Pretty simple! It works just like a normal <code>Vec</code> does in rust with indexing. Let's also update the <code>is_alive</code> function to use our new <code>get_cell</code> helper:</p>
<pre><code class="language-glsl">fn is_alive(location: vec2&lt;i32&gt;, offset_x: i32, offset_y: i32) -&gt; u32 {
    var loc = ((location + vec2&lt;i32&gt;(offset_x, offset_y)) + vec2&lt;i32&gt;(size)) % vec2&lt;i32&gt;(size);
    return aliveSrc[idx(loc)].alive; // NEW!!
}
</code></pre>
<p>Now our update function is going to be a bit more complicated. The heat map will work as follows, an alive cell will have a heat of <code>255</code> and a dead cell,
will subtract <code>1</code> from its heat each frame. We will color dead cells with the heat value provided, so it will dwindle as they remain dead.</p>
<pre><code class="language-glsl">@compute @workgroup_size(8, 8, 1)
fn update(@builtin(global_invocation_id) invocation_id: vec3&lt;u32&gt;) {
    let location = vec2&lt;i32&gt;(invocation_id.xy);
    let num_neighbors = count_neighbors_simple(location);
    var cell = get_cell(location);  // NEW!!
    let is_alive = bool(cell.alive);  // NEW!!

    var result: u32 = 0u;
    var heat: u32 = cell.heat; // NEW!!

    if (is_alive) { 
        result = ((u32((num_neighbors) == (2u))) | (u32((num_neighbors) == (3u)))); 
    } else { 
        result = u32((num_neighbors) == (3u)); 
    }

    var color: vec4&lt;f32&gt; = vec4&lt;f32&gt;(f32(result), 0., 0., 1.);
    if (bool(result)){
        heat = 255u;
    } else {
        color = vec4&lt;f32&gt;(0., 0., 0., 1.);

        if (heat &gt; 0u){
            heat -= 1u;
            color = vec4&lt;f32&gt;(0., 0., f32(heat) / 255., 1.0);
        }
    }

    aliveDts[idx(location)] = Cell(result, heat);
    textureStore(texture, location, color);
}
</code></pre>
<p>So we grab our current cell, and run the same ruleset we did previously with <code>Conway's Game of Life</code>. The new addition is checking if the
<code>cell</code> is alive or dead. If alive, we set the heat to <code>255</code> and the color will be red. If dead AND heat is greater than <code>0</code> we subtract <code>1</code>
from the heat, and  color the cell with the heat value in the <code>blue</code> channel. Otherwise, the cell is colored <code>black</code>.</p>
<p><img src="bevy_gol_example/images/heatmap_no_draw.gif" alt="game_of_life" /></p>
<p>We lost the ability to draw our cells, but it is a simple fix and a nice challenge!</p>
<blockquote>
<p>Challenge-1: Convert the draw pipeline and draw shader to use the new buffers! Hint: We only need 1 buffer to write to in the draw shader.</p>
</blockquote>
<blockquote>
<p>Challenge-2: Create a third pipeline called <code>ColorPipeline</code> that will take in the <code>aliveDts</code> buffer and color the cells based on their heat value instead
of coloring them within our <code>game_of_life</code> shader.</p>
</blockquote>
<details>
<summary>Challenge Spoiler 1</summary>
<p>draw.rs</p>
<pre><code class="language-rust">use bevy::{
    prelude::*,
    render::{render_graph, render_resource::*, renderer::*, RenderSet},
};
use std::borrow::Cow;

use crate::{input::AutomataParams, NUM_OF_CELLS, SIM_SIZE, WORKGROUP_SIZE};

use super::automata::{AutomataTextureBindGroup, GameOfLifeBuffers};

pub struct AutomataDrawPipelinePlugin;
impl Plugin for AutomataDrawPipelinePlugin {
    fn build(&amp;self, render_app: &amp;mut App) {
        render_app
            .init_resource::&lt;AutomataDrawPipeline&gt;()
            .add_system(queue_draw_bind_group.in_set(RenderSet::Queue));
    }
}

// ================================== Contants ================================== //

#[repr(C)]
#[derive(Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]
pub struct AutomataPushConstants {
    draw_start: [f32; 2],
    draw_end: [f32; 2],
    draw_radius: f32,
    draw_square: u32,
}

impl AutomataPushConstants {
    pub fn new(draw_start: Vec2, draw_end: Vec2, draw_radius: f32, draw_square: bool) -&gt; Self {
        Self {
            draw_radius,
            draw_end: draw_end.to_array(),
            draw_square: draw_square as u32,
            draw_start: draw_start.to_array(),
        }
    }
}

// ================================== Pipeline ================================== //

#[derive(Resource)]
pub struct AutomataDrawPipeline {
    draw_pipeline: CachedComputePipelineId,
    draw_bind_group_layout: BindGroupLayout,
}

impl FromWorld for AutomataDrawPipeline {
    fn from_world(world: &amp;mut World) -&gt; Self {
        let pipeline_cache = world.resource::&lt;PipelineCache&gt;();

        let draw_bind_group_layout =
            world
                .resource::&lt;RenderDevice&gt;()
                .create_bind_group_layout(&amp;BindGroupLayoutDescriptor {
                    label: Some("Game of Life Draw Bind Group Layout"),
                    entries: &amp;[
                        BindGroupLayoutEntry {
                            binding: 0,
                            count: None,
                            visibility: ShaderStages::COMPUTE,
                            ty: BindingType::Buffer {
                                ty: BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: BufferSize::new(
                                    (2 * std::mem::size_of::&lt;u32&gt;()) as _,
                                ),
                            },
                        },
                        BindGroupLayoutEntry {
                            binding: 1,
                            count: None,
                            visibility: ShaderStages::COMPUTE,
                            ty: BindingType::Buffer {
                                ty: BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: BufferSize::new(
                                    (2 * NUM_OF_CELLS * std::mem::size_of::&lt;u32&gt;()) as _,
                                ),
                            },
                        },
                    ],
                });

        let brush_shader = world.resource::&lt;AssetServer&gt;().load("shaders/draw.wgsl");

        let draw_pipeline = pipeline_cache.queue_compute_pipeline(ComputePipelineDescriptor {
            shader: brush_shader,
            shader_defs: vec![],
            entry_point: Cow::from("draw"),
            layout: vec![draw_bind_group_layout.clone()],
            label: Some(std::borrow::Cow::Borrowed("Game of Life Draw Pipeline")),
            push_constant_ranges: [PushConstantRange {
                stages: ShaderStages::COMPUTE,
                range: 0..std::mem::size_of::&lt;AutomataPushConstants&gt;() as u32,
            }]
            .to_vec(),
        });

        AutomataDrawPipeline {
            draw_pipeline,
            draw_bind_group_layout,
        }
    }
}

// ================================== BindGroup ================================== //

#[derive(Resource)]
struct AutomataDrawBindGroup(pub BindGroup);

pub fn queue_draw_bind_group(
    mut commands: Commands,
    render_device: Res&lt;RenderDevice&gt;,

    params: Res&lt;AutomataParams&gt;,
    buffers: Res&lt;GameOfLifeBuffers&gt;,
    pipeline: Res&lt;AutomataDrawPipeline&gt;,
) {
    let draw_bind_group = render_device.create_bind_group(&amp;BindGroupDescriptor {
        label: Some("Game of Life Draw Bind Group"),
        layout: &amp;pipeline.draw_bind_group_layout,
        entries: &amp;[
            BindGroupEntry {
                binding: 0,
                resource: buffers.uniform_buffer.as_entire_binding(),
            },
            BindGroupEntry {
                binding: 1,
                resource: buffers.in_out_buffers[*params.frame.lock() % 2].as_entire_binding(),
            },
        ],
    });
    commands.insert_resource(AutomataDrawBindGroup(draw_bind_group));
}

// ================================== Nodes ================================== //
pub enum AutomataDrawState {
    Loading,
    Update,
}

pub struct AutomataDrawNode {
    state: AutomataDrawState,
}

impl Default for AutomataDrawNode {
    fn default() -&gt; Self {
        Self {
            state: AutomataDrawState::Loading,
        }
    }
}

impl render_graph::Node for AutomataDrawNode {
    fn update(&amp;mut self, world: &amp;mut World) {
        let pipeline_cache = world.resource::&lt;PipelineCache&gt;();
        let pipeline = world.resource::&lt;AutomataDrawPipeline&gt;();

        // if the corresponding pipeline has loaded, transition to the next stage
        match self.state {
            AutomataDrawState::Loading =&gt; {
                if let CachedPipelineState::Ok(_) =
                    pipeline_cache.get_compute_pipeline_state(pipeline.draw_pipeline)
                {
                    self.state = AutomataDrawState::Update;
                }
            }
            AutomataDrawState::Update =&gt; {}
        }
    }

    fn run(
        &amp;self,
        _graph: &amp;mut render_graph::RenderGraphContext,
        render_context: &amp;mut RenderContext,
        world: &amp;World,
    ) -&gt; Result&lt;(), render_graph::NodeRunError&gt; {
        let params = &amp;world.resource::&lt;AutomataParams&gt;();

        if params.is_drawing {
            let texture_bind_group = &amp;world.resource::&lt;AutomataTextureBindGroup&gt;().0;
            let draw_bind_group = &amp;world.resource::&lt;AutomataDrawBindGroup&gt;().0;
            let pipeline_cache = world.resource::&lt;PipelineCache&gt;();
            let pipeline = world.resource::&lt;AutomataDrawPipeline&gt;();

            let mut pass = render_context
                .command_encoder()
                .begin_compute_pass(&amp;ComputePassDescriptor::default());

            pass.set_bind_group(0, texture_bind_group, &amp;[]);

            // select the pipeline based on the current state
            match self.state {
                AutomataDrawState::Loading =&gt; {}
                AutomataDrawState::Update =&gt; {
                    let draw_pipeline = pipeline_cache
                        .get_compute_pipeline(pipeline.draw_pipeline)
                        .unwrap();

                    let pc = AutomataPushConstants::new(
                        params.mouse_pos,
                        params.prev_mouse_pos,
                        params.radius,
                        params.use_square_brush,
                    );

                    pass.set_pipeline(draw_pipeline);
                    pass.set_bind_group(0, draw_bind_group, &amp;[]);
                    pass.set_push_constants(0, bytemuck::cast_slice(&amp;[pc]));
                    pass.dispatch_workgroups(
                        SIM_SIZE.0 / WORKGROUP_SIZE,
                        SIM_SIZE.1 / WORKGROUP_SIZE,
                        1,
                    );
                }
            }
        }

        Ok(())
    }
}</code></pre>
<p>draw.wgsl</p>
<pre><code class="language-glsl">#import bevy_shader_playground::core

@group(0) @binding(0) 
var&lt;uniform&gt; size : vec2&lt;u32&gt;; // width, height
@group(0) @binding(1) 
var&lt;storage, read_write&gt; aliveDts : array&lt;Cell&gt;;

// Line v-&gt;w, point p
// https://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment
fn closest_point_on_line(v: vec2&lt;f32&gt;, w: vec2&lt;f32&gt;, p: vec2&lt;f32&gt;) -&gt; vec2&lt;f32&gt; {
    let c = v - w;
    // length squared
    let l2 = dot(c, c);
    if (l2 == 0.0) {
        return v;
    }
    let t = max(0.0, min(1.0, dot(p - v, w - v) / l2));
    let projection = v + t * (w - v);
    return projection;
}

fn draw_particle_circle(pos: vec2&lt;f32&gt;, draw_pos: vec2&lt;f32&gt;, radius: f32) {
    let y_start = draw_pos.y - radius;
    let y_end = draw_pos.y + radius;
    let x_start = draw_pos.x - radius;
    let x_end = draw_pos.x + radius;
    if (pos.x &gt;= x_start &amp;&amp; pos.x &lt;= x_end &amp;&amp; pos.y &gt;= y_start &amp;&amp; pos.y &lt;= y_end) {
        let diff = pos - draw_pos;
        let dist = length(diff);
        if (round(dist) &lt;= radius) {
            aliveDts[idx(vec2&lt;i32&gt;(pos))] = new_cell(true);
        }
    }
}

fn draw_particle_square(pos: vec2&lt;f32&gt;, draw_pos: vec2&lt;f32&gt;, size: f32)  {
    let y_start = draw_pos.y - size / 2.;
    let y_end = draw_pos.y + size / 2.;
    let x_start = draw_pos.x - size / 2.;
    let x_end = draw_pos.x + size / 2.;
    if (pos.x &gt;= x_start &amp;&amp; pos.x &lt;= x_end &amp;&amp; pos.y &gt;= y_start &amp;&amp; pos.y &lt;= y_end) {
        aliveDts[idx(vec2&lt;i32&gt;(pos))] = new_cell(true);
    }
}

@compute @workgroup_size(8, 8, 1)
fn draw(@builtin(global_invocation_id) invocation_id: vec3&lt;u32&gt;)
{
    let pixel = vec2&lt;u32&gt;(invocation_id.xy);
    if (pixel.x &gt;= size.x &amp;&amp; pixel.y &gt;= size.y) {
        return ;
    }

    if (pc.draw_radius &gt; 0.0) {
        let pos = vec2&lt;f32&gt;(pixel);
        let point_on_line = closest_point_on_line(pc.draw_start, pc.draw_end, pos);

        if (bool(pc.draw_square)){
            draw_particle_square(pos, point_on_line, pc.draw_radius);
        }else{
            draw_particle_circle(pos, point_on_line, pc.draw_radius);
        }
    }
}
</code></pre>
<p><img src="bevy_gol_example/images/heatmap_draw.gif" alt="heatmap_draw" /></p>
</details>
<p>Challenge 2 along with the full source code can be found on github: <a href="https://github.com/bayou-brogrammer/bevy_shader_playground/tree/explore_part5/sims/game_of_life_sim/src">Part 5</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
