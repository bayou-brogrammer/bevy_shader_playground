<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>What are shaders?! - Bevy Shader Playground</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Exploring Bevy's Game of Life Example</li><li class="chapter-item expanded "><a href="../bevy_gol_example/index.html"><strong aria-hidden="true">1.</strong> Bevy's Game of Life Example</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../bevy_gol_example/part_1.html" class="active"><strong aria-hidden="true">1.1.</strong> What are shaders?!</a></li><li class="chapter-item expanded "><a href="../bevy_gol_example/part_2.html"><strong aria-hidden="true">1.2.</strong> Diving deeper into shaders</a></li><li class="chapter-item expanded "><a href="../bevy_gol_example/part_3.html"><strong aria-hidden="true">1.3.</strong> Making cells dance</a></li><li class="chapter-item expanded "><a href="../bevy_gol_example/part_4.html"><strong aria-hidden="true">1.4.</strong> Paint like Picaso</a></li><li class="chapter-item expanded "><a href="../bevy_gol_example/part_5.html"><strong aria-hidden="true">1.5.</strong> Buffers and UI, Oh My!</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Bevy Shader Playground</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/bayou-brogrammer/bevy_shader_playground/tree/main/docs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/bayou-brogrammer/bevy_shader_playground/edit/main/docs/src/bevy_gol_example/part_1.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="bevy-game-of-life-shader-example-part-1"><a class="header" href="#bevy-game-of-life-shader-example-part-1">Bevy Game of Life Shader Example Part 1</a></h1>
<p>As a fun exercise, I decided to explore using compute shaders using wgpu within bevy. This is part 1 of exploring bevy game of life shader example, and
some ways to enhance the experience.</p>
<p>I assume you have general knowledge of rust, bevy, and wgpu, but I will still explain somethings along the way. If you need a refresher on anything, here
are some helpful resources:</p>
<p><a href="https://doc.rust-lang.org/book/">Learn Rust</a></p>
<p><a href="https://bevyengine.org/learn/book/introduction/">Bevy Book</a></p>
<p><a href="https://bevy-cheatbook.github.io/">Bevy Cheatbook</a></p>
<p><a href="https://sotrh.github.io/learn-wgpu/">Learn Wgpu</a></p>
<p>If you are still ready, lets get started!</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>This tutorial currently follows along using <code>Bevy 0.10</code></p>
<p>I am using the <a href="https://github.com/NiklasEi/bevy_game_template">bevy_game_template</a> as my starter, just with all the extra code ripped out,
except for main and lib.</p>
<pre><code class="language-rust">// main.rs

// &lt;imports&gt;
...

fn main() {
    App::new()
        .insert_resource(ClearColor(Color::BLACK))
        .add_plugins(DefaultPlugins.set(WindowPlugin {
            primary_window: Some(Window {
                canvas: Some("#shader_playground".to_owned()),
                title: "Shader Playground".to_string(),
                present_mode: bevy::window::PresentMode::AutoNoVsync, // unthrottled FPS
                ..default()
            }),
            ..default()
        }))
        .add_plugin(ShaderPlaygroundPlugin)
        .add_system(set_window_icon.on_startup())
        .run();
}

// &lt;window_icon sys&gt;
...
</code></pre>
<pre><code class="language-rust">// lib.rs

// &lt;imports&gt;
...

const SIM_SIZE: (u32, u32) = (1280, 720);
const WORKGROUP_SIZE: u32 = 8;

pub struct ShaderPlaygroundPlugin;
impl Plugin for ShaderPlaygroundPlugin {
    fn build(&amp;self, app: &amp;mut App) {
        app.add_plugin(FrameTimeDiagnosticsPlugin::default())
            .add_system(window_fps);
    }
}

fn window_fps(diagnostics: Res&lt;Diagnostics&gt;, mut windows: Query&lt;&amp;mut Window, With&lt;PrimaryWindow&gt;&gt;) {
    if let Ok(mut window) = windows.get_single_mut() {
        if let Some(fps_diagnostic) = diagnostics.get(FrameTimeDiagnosticsPlugin::FPS) {
            if let Some(fps_smoothed) = fps_diagnostic.smoothed() {
                window.title = format!("{fps_smoothed:.2}");
            }
        }
    }
}
</code></pre>
<p>Pretty simple setup. Just added a simple fps system to print the FPS at the top of the window. We need to setup our canvas for our simulation.
We will just use a simple image constrained to our <code>SIM_SIZE</code> variable. You can organize your code how you feel, but I will be breaking out the code
from the original example into separate files for readability.</p>
<pre><code class="language-rust">// image.rs

#[derive(Resource, Clone, Deref, ExtractResource)]
pub struct GameOfLifeImage(pub Handle&lt;Image&gt;);

pub fn create_image(width: u32, height: u32) -&gt; Image {
    let mut image = Image::new_fill(
        Extent3d {
            width,
            height,
            depth_or_array_layers: 1,
        },
        TextureDimension::D2,
        &amp;[0, 0, 0, 255],
        TextureFormat::Rgba8Unorm,
    );

    image.texture_descriptor.usage =
        TextureUsages::COPY_DST | TextureUsages::STORAGE_BINDING | TextureUsages::TEXTURE_BINDING;

    image
}
</code></pre>
<p>This is just a simple helper function to create an image. We will be using this to create our simulation image. <code>GameOfLifeImage</code> will hold a reference to our
handle image so that it doesn't get unloaded. You will see it is annotated with <code>ExtractResource</code> derive. This is required to extract the image from the main bevy
world into the render world. You can also manually derive this, if needed. Lets use it within our setup function. Back in
<code>lib.rs</code>:</p>
<pre><code class="language-rust">...
fn setup(mut commands: Commands, mut images: ResMut&lt;Assets&lt;Image&gt;&gt;) {
    let image = image::create_image(SIM_SIZE.0, SIM_SIZE.1);
    let image = images.add(image);

    commands.spawn(SpriteBundle {
        sprite: Sprite {
            custom_size: Some(Vec2::new(SIM_SIZE.0 as f32, SIM_SIZE.1 as f32)),
            ..default()
        },
        texture: image.clone(),
        ..default()
    });

    commands.spawn(Camera2dBundle::default());
    commands.insert_resource(image::GameOfLifeImage(image));
}</code></pre>
<p>Quick and easy. Just create our image, create a sprite based off the image, spawn a 2D camera, and then inject our resource into bevy world.
Now we just need to hookup our system back in the plugin.</p>
<pre><code class="language-rust">fn build(&amp;self, app: &amp;mut App) {
    app.add_plugin(FrameTimeDiagnosticsPlugin::default())
        .add_startup_system(setup)
        .add_system(window_fps);
}</code></pre>
<p>Running the simulation should produce a black screen and nothing more. But hey! No errors! Lets move on.</p>
<p>As mentioned earlier, bevy has a render world which is extracted each render instance. We need to tell our render setup how to access members from the main world.
In our plugin, add the <code>ExtractResourcePlugin</code> for our <code>GameOfLifeImage</code> resource.</p>
<pre><code class="language-rust">...
// Extract the game of life image resource from the main world into the render world
// for operation on by the compute shader and display on the sprite.
app.add_plugin(ExtractResourcePlugin::&lt;GameOfLifeImage&gt;::default());
...</code></pre>
<p>Now onto the actual meat of why I am writing this. Lets get into wgpu. We will be using a compute shader, so our pipeline will need to be a <code>ComputePipeline</code>.</p>
<blockquote>
<p>A pipeline describes all the actions the gpu will perform when acting on a set of data</p>
</blockquote>
<p>Lets create a new file, <code>pipeline.rs</code> and add the following:</p>
<pre><code class="language-rust">use bevy::{prelude::*, render::render_resource::*};

#[derive(Resource)]
pub struct GameOfLifePipeline {
    init_pipeline: CachedComputePipelineId,
    update_pipeline: CachedComputePipelineId,
    texture_bind_group_layout: BindGroupLayout,
}

impl FromWorld for GameOfLifePipeline {
    fn from_world(world: &amp;mut World) -&gt; Self {}
}
</code></pre>
<p>Our pipeline resource holds the two compute pipeline id's we will be using init (for setup) and update (for each frame). We also need to hold onto
the bind group layout.</p>
<blockquote>
<p>a bind group layout is a way to describe the structure of resources that a shader will access during execution. The resources include buffers, textures, and samplers</p>
</blockquote>
<p>Lets expand upon our <code>FromWorld</code> implementation.</p>
<pre><code class="language-rust">impl FromWorld for GameOfLifePipeline {
    fn from_world(world: &amp;mut World) -&gt; Self {
        let texture_bind_group_layout =
            world
                .resource::&lt;RenderDevice&gt;()
                .create_bind_group_layout(&amp;BindGroupLayoutDescriptor {
                    label: Some("Game of Life Bind Group Layout"),
                    entries: &amp;[BindGroupLayoutEntry {
                        binding: 0,
                        visibility: ShaderStages::COMPUTE,
                        ty: BindingType::StorageTexture {
                            access: StorageTextureAccess::ReadWrite,
                            format: TextureFormat::Rgba8Unorm,
                            view_dimension: TextureViewDimension::D2,
                        },
                        count: None,
                    }],
                });

        let pipeline_cache = world.resource::&lt;PipelineCache&gt;();
        let shader = world
            .resource::&lt;AssetServer&gt;()
            .load("shaders/game_of_life.wgsl");

        ...</code></pre>
<p>WHOA! What is this weird layout stuff? First thing first, the <code>RenderDevice</code> is equivalent to <code>wgpu::Device</code>. We are just using the bevy wrapper.
I like to add labels to all my shader creations, just to make it easier to track bugs when they do arise. This layout is telling the pipeline that at
binding(0) we expect there to be a binding of type <code>StorageTexture</code>, that is read_write, and has the format of <code>Rgba8Unorm</code>.</p>
<p>We then pull the pipeline cache to create our pipelines and pull our shader from the asset's folder.</p>
<h2 id="compute-shaders"><a class="header" href="#compute-shaders">Compute Shaders</a></h2>
<blockquote>
<p>A compute shader is simply a shader that allows you to leverage the GPU's parallel computing power for arbitrary tasks. You can use them for anything from creating a texture to running a neural network. I'll get more into how they work in a bit, but for now suffice to say that we're going to use them to create the vertex and index buffers for our terrain.
As of writing, compute shaders are still experimental on the web. You can enable them on beta versions of browsers such as Chrome Canary and Firefox Nightly. Because of this I'll cover a method to use a fragment shader to compute the vertex and index buffers after we cover the compute shader method.</p>
</blockquote>
<pre><code class="language-rust">    let init_pipeline = pipeline_cache.queue_compute_pipeline(ComputePipelineDescriptor {
        shader: shader.clone(),
        shader_defs: vec![],
        layout: vec![texture_bind_group_layout.clone()],
        entry_point: Cow::from("init"),
        push_constant_ranges: Vec::new(),
        label: Some(std::borrow::Cow::Borrowed("Game of Life Init Pipeline")),
    });
    let update_pipeline = pipeline_cache.queue_compute_pipeline(ComputePipelineDescriptor {
        shader,
        shader_defs: vec![],
        layout: vec![texture_bind_group_layout.clone()],
        entry_point: Cow::from("update"),
        push_constant_ranges: Vec::new(),
        label: Some(std::borrow::Cow::Borrowed("Game of Life Update Pipeline")),
    });

    GameOfLifePipeline {
        texture_bind_group_layout,
        init_pipeline,
        update_pipeline,
    }</code></pre>
<p>The init and update pipeline use the same layout and shader. We are not using push constants yet, so we can leave that as an empty vector, same with shader_defs.
The important part is the entry_point. This is the name of the function in the shader that will be executed.</p>
<p>Lets quickly setup our shader and then we can move onto the actual compute shader.</p>
<pre><code class="language-glsl">// assets/game_of_life.wgsl

@group(0) @binding(0)
var texture: texture_storage_2d&lt;rgba8unorm, read_write&gt;;

@compute @workgroup_size(8, 8, 1)
fn init(@builtin(global_invocation_id) invocation_id: vec3&lt;u32&gt;, @builtin(num_workgroups) num_workgroups: vec3&lt;u32&gt;) {}

@compute @workgroup_size(8, 8, 1)
fn update(@builtin(global_invocation_id) invocation_id: vec3&lt;u32&gt;) {}
</code></pre>
<p>We can see that from what we defined in our <code>BindGroupLayoutDescriptor</code> that we define a <code>texture_storage_2d&lt;rgba8unorm, read_write&gt;</code> at <code>binding(0)</code>. Looking
back at our descriptor:</p>
<pre><code class="language-rust">BindGroupLayoutDescriptor {
    label: Some("Game of Life Bind Group Layout"),
    entries: &amp;[BindGroupLayoutEntry {
        binding: 0,
        visibility: ShaderStages::COMPUTE,
        ty: BindingType::StorageTexture {
            access: StorageTextureAccess::ReadWrite,
            format: TextureFormat::Rgba8Unorm,
            view_dimension: TextureViewDimension::D2,
        },
        count: None,
    }],
}</code></pre>
<p>We see that our <code>BindGroupLayoutEntry</code> matches what we expect at <code>group(0) binding(0)</code>. This has to match 1:1, otherwise wgpu will panic on run.</p>
<p>Afterwards, we simply just adds our entry points that we defined in the pipeline's. The <code>@workgroup_size</code> is the size of the workgroup that will be
executed on the gpu. Bevy example uses 8.
Let's add our newly created pipeline resource to the render world. Back in the plugin:</p>
<pre><code class="language-rust">...
let render_app = app.sub_app_mut(RenderApp);
render_app.init_resource::&lt;GameOfLifePipeline&gt;();</code></pre>
<p>Running the example now should produce the same screen, but still no errors. We are getting closer to actually doing something. More in part 2.</p>
<p>Code can be found on github: <a href="https://github.com/bayou-brogrammer/bevy_shader_playground/tree/explore_part1/sims/game_of_life_sim/src">Part 1</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../bevy_gol_example/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../bevy_gol_example/part_2.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../bevy_gol_example/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../bevy_gol_example/part_2.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
